<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cans - The Ultimate Cat Boss Fight Enhanced</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #gameContainer {
            width: 800px;
            height: 600px;
            background: #000;
            border: 4px solid #fff;
            position: relative;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        .dialogue-box {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 120px;
            background: #000;
            border: 3px solid #fff;
            padding: 10px;
            box-sizing: border-box;
            display: none;
        }
        
        .dialogue-text {
            color: #fff;
            font-size: 16px;
            line-height: 1.4;
        }
        
        .menu {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 10;
        }
        
        .menu-button {
            display: inline-block;
            margin: 0 10px;
            padding: 15px 25px;
            border: 3px solid #fff;
            background: #000;
            color: #fff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            user-select: none;
            transition: all 0.2s ease;
        }
        
        .menu-button:hover, .menu-button.selected {
            background: #fff;
            color: #000;
            transform: scale(1.1);
        }

        .menu-button.destroyed {
            background: #1a0000 !important;
            color: #333 !important;
            border: 3px solid #333 !important;
            cursor: not-allowed !important;
            position: relative;
            overflow: hidden;
            opacity: 0.3 !important;
            transform: rotate(-5deg) scale(0.8) !important;
            animation: buttonGlitch 0.5s infinite;
            pointer-events: none !important;
        }

        @keyframes buttonGlitch {
            0% { transform: rotate(-5deg) scale(0.8) translateX(0px); }
            25% { transform: rotate(-4deg) scale(0.75) translateX(-1px); }
            50% { transform: rotate(-6deg) scale(0.85) translateX(1px); }
            75% { transform: rotate(-5deg) scale(0.8) translateX(-1px); }
            100% { transform: rotate(-5deg) scale(0.8) translateX(0px); }
        }

        .menu-button.destroyed::before {
            content: '✗ DESTROYED ✗';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: #ff0000;
            z-index: 1;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
        }

        .menu-button.destroyed::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                45deg,
                rgba(255, 0, 0, 0.2),
                rgba(255, 0, 0, 0.2) 5px,
                rgba(0, 0, 0, 0.3) 5px,
                rgba(0, 0, 0, 0.3) 10px
            );
            z-index: 0;
        }

        .menu-button.destroyed:hover {
            background: #1a0000 !important;
            color: #333 !important;
            transform: rotate(-5deg) scale(0.8) !important;
        }

        .menu-button.destroyed.selected {
            background: #1a0000 !important;
            color: #333 !important;
            transform: rotate(-5deg) scale(0.8) !important;
        }
        
        .stats {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 14px;
            z-index: 5;
        }
        
        .attack-info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            font-size: 12px;
            z-index: 5;
        }
        
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            font-size: 18px;
            z-index: 100;
        }
        
        .menu-instructions {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #ffff00;
            font-size: 14px;
            z-index: 15;
            display: none;
        }
        
        .fade-out {
            opacity: 0;
            transition: opacity 2s;
        }
        
        .status-effect {
            position: absolute;
            top: 80px;
            left: 10px;
            color: #ff69b4;
            font-size: 12px;
            z-index: 5;
        }

        .ending-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            z-index: 1000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .victory-text, .gameover-text {
            text-align: center;
            color: #ffff00;
            font-size: 24px;
            z-index: 100;
            display: none;
            margin-bottom: 20px;
        }

        .gameover-text {
            color: #ff0000;
        }

        .restart-button {
            background: #000;
            border: 3px solid #fff;
            color: #fff;
            padding: 15px 30px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            transition: all 0.2s ease;
            margin-top: 20px;
        }

        .restart-button:hover {
            background: #fff;
            color: #000;
            transform: scale(1.1);
        }

        .audio-controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .audio-btn {
            background: #000;
            border: 2px solid #fff;
            color: #fff;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .audio-btn:hover {
            background: #fff;
            color: #000;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .volume-slider {
            width: 80px;
            height: 20px;
            background: #333;
            border: 1px solid #fff;
            appearance: none;
            outline: none;
        }

        .volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 18px;
            background: #fff;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 15px;
            height: 18px;
            background: #fff;
            cursor: pointer;
            border: none;
        }

        .audio-status {
            color: #00ff00;
            font-size: 10px;
        }

        .attack-type-indicator {
            position: absolute;
            top: 120px;
            left: 10px;
            color: #ffff00;
            font-size: 12px;
            z-index: 5;
        }

        .music-indicator {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff69b4;
            font-size: 10px;
            z-index: 10;
            text-align: center;
        }

        .rage-mode-indicator {
            position: absolute;
            top: 60px;
            right: 10px;
            color: #ff0000;
            font-size: 14px;
            z-index: 5;
            display: none;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Cutscene styles */
        .cutscene-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .cutscene-dialogue {
            background: #000;
            border: 3px solid #fff;
            padding: 30px;
            margin: 20px;
            max-width: 600px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            color: #fff;
            line-height: 1.6;
        }

        .dramatic-text {
            color: #ff0000;
            text-shadow: 2px 2px 4px #000;
            animation: textShake 0.3s infinite alternate;
        }

        @keyframes textShake {
            0% { transform: translateX(-1px); }
            100% { transform: translateX(1px); }
        }

        .screen-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #ff0000;
            opacity: 0;
            z-index: 99;
            pointer-events: none;
        }

        .screen-shake {
            animation: screenShake 0.5s infinite;
        }

        @keyframes screenShake {
            0% { transform: translateX(-2px) translateY(-2px); }
            25% { transform: translateX(2px) translateY(-2px); }
            50% { transform: translateX(-2px) translateY(2px); }
            75% { transform: translateX(2px) translateY(2px); }
            100% { transform: translateX(-2px) translateY(-2px); }
        }

        /* Language toggle button */
        .language-toggle {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 1000;
        }

        .language-btn {
            background: #000;
            border: 2px solid #fff;
            color: #fff;
            padding: 8px 15px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .language-btn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.1);
        }

        .language-hint {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: #888;
            font-size: 12px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <!-- Screen effects -->
        <div class="screen-flash" id="screenFlash"></div>
        
        <!-- Audio Controls -->
        <div class="audio-controls">
            <button class="audio-btn" id="musicToggle">🔊 MUTE</button>
            <div class="volume-control">
                <span style="color: #fff; font-size: 12px;">VOL:</span>
                <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="50">
                <span class="audio-status" id="audioStatus">READY</span>
            </div>
        </div>

        <div class="music-indicator" id="musicIndicator">
            <span id="currentTrack">♪ Last Goodbye ♪</span>
        </div>
        
        <!-- Background Music -->
        <audio id="backgroundMusic" loop preload="auto">
            <source src="./public/last_goodbye.mp3" type="audio/mpeg">
            Your browser does not support the audio element.
        </audio>

        <!-- Rage Mode Music -->
        <audio id="rageMusic" loop preload="auto">
            <source src="./public/MEGALOVANIA.mp3" type="audio/mpeg">
            Your browser does not support the audio element.
        </audio>
        
        <div class="stats">
            <div><span id="hpLabel">HP</span>: <span id="playerHP">20</span>/20</div>
            <div><span id="bossHPLabel">Cans HP</span>: <span id="bossHP">250</span>/250</div>
        </div>
        
        <div class="attack-info" id="attackInfo">
            <div><span id="phaseLabel">Phase</span>: <span id="currentPhase">1</span></div>
            <div><span id="attackLabel">Attack</span>: <span id="currentAttack">Preparing...</span></div>
        </div>

        <div class="attack-type-indicator" id="attackTypeIndicator">
            <div><span id="tipLabel">TIP</span>: <span id="attackTip">Move to dodge white attacks!</span></div>
        </div>

        <div class="rage-mode-indicator" id="rageModeIndicator">
            RAGE MODE ACTIVE!
        </div>
        
        <div class="status-effect" id="statusEffect"></div>
        
        <div id="instructions">
            <h2 id="gameTitle">🐱 CANS - THE ULTIMATE CAT 🐱</h2>
            <p id="instructLine1">Use ARROW KEYS or WASD to move your heart and dodge attacks!</p>
            <p id="instructLine2">Different colored attacks have special effects:</p>
            <p style="color: #fff;" id="whiteAttack">⚪ WHITE: Hurts when touched</p>
            <p style="color: #00ff00;" id="greenAttack">🟢 GREEN: Heals when touched</p>
            <p style="color: #87ceeb;" id="blueAttack">🔵 BLUE: Hurts only when moving</p>
            <p style="color: #ffa500;" id="orangeAttack">🟠 ORANGE: Hurts only when still</p>
            <p id="instructLine3">Choose your actions wisely during battle!</p>
            <p style="color: #ff69b4;" id="instructLine4">Battle will be longer, but your choices will shape the music!</p>
            <p id="instructLine5">Press SPACE to continue</p>
            <p class="language-hint" id="languageHint">Press SPACE or ENTER to change language</p>
        </div>
        
        <div class="menu-instructions" id="menuInstructions">
            <p id="menuInstructText">Use ARROW KEYS to select • Press ENTER to confirm • Click with mouse</p>
        </div>
        
        <div class="menu" id="menu">
            <div class="menu-button" data-action="fight" id="fightBtn">FIGHT</div>
            <div class="menu-button" data-action="act" id="actBtn">ACT</div>
            <div class="menu-button" data-action="item" id="itemBtn">ITEM</div>
            <div class="menu-button" data-action="mercy" id="mercyBtn">MERCY</div>
        </div>
        
        <div class="dialogue-box" id="dialogue">
            <div class="dialogue-text" id="dialogueText"></div>
        </div>

        <!-- Dramatic Cutscene -->
        <div class="cutscene-overlay" id="cutsceneOverlay">
            <div class="cutscene-dialogue" id="cutsceneDialogue">
                <div id="cutsceneText"></div>
                <p style="margin-top: 30px; color: #888; font-size: 14px;" id="cutsceneContinue">Press SPACE to continue...</p>
            </div>
        </div>

        <div class="ending-overlay" id="endingOverlay">
            <div class="victory-text" id="victoryText">
                <h1 id="victoryTitle">✨ VICTORY ✨</h1>
                <p id="victoryMessage">You have befriended Cans!</p>
            </div>
            <div class="gameover-text" id="gameoverText">
                <h1 id="gameoverTitle">💀 GAME OVER 💀</h1>
                <p id="gameoverMessage">Cans sits on your keyboard triumphantly...</p>
            </div>
            <button class="restart-button" id="restartButton">RESTART GAME</button>
        </div>

        <!-- Language Toggle -->
        <div class="language-toggle">
            <button class="language-btn" id="languageBtn">中文</button>
        </div>
    </div>

    <script>
        // Simplified frame rate system
        let frameCount = 0;
        
        // Image loading
        const catPawImage = new Image();
        catPawImage.src = './public/catpaw.png';
        let imageLoaded = false;
        
        catPawImage.onload = () => {
            imageLoaded = true;
            console.log('Cat paw image loaded successfully');
        };
        
        catPawImage.onerror = () => {
            console.error('Failed to load cat paw image');
        };
        
        // Language system
        let currentLanguage = 'en';
        
        const translations = {
            en: {
                // UI Elements
                hp: 'HP',
                bossHP: 'Cans HP',
                phase: 'Phase',
                attack: 'Attack',
                tip: 'TIP',
                preparing: 'Preparing...',
                mute: '🔊 MUTE',
                unmute: '🔇 UNMUTE',
                vol: 'VOL:',
                ready: 'READY',
                loading: 'LOADING',
                error: 'ERROR',
                playing: 'PLAYING',
                paused: 'PAUSED',
                clickToPlay: 'CLICK TO PLAY',
                seriousMode: '♪ SERIOUS MODE ♪',
                rageModeActive: 'RAGE MODE ACTIVE!',
                languageHint: 'Press SPACE or ENTER to change language',
                
                // Menu buttons
                fight: 'FIGHT',
                act: 'ACT',
                item: 'ITEM',
                mercy: 'MERCY',
                destroyed: 'DESTROYED',
                destroyedMessage: '✗ DESTROYED ✗',
                
                // Game title and instructions
                gameTitle: '🐱 CANS - THE ULTIMATE CAT 🐱',
                instructLine1: 'Use ARROW KEYS or WASD to move your heart and dodge attacks!',
                instructLine2: 'Different colored attacks have special effects:',
                whiteAttack: '⚪ WHITE: Hurts when touched',
                greenAttack: '🟢 GREEN: Heals when touched',
                blueAttack: '🔵 BLUE: Hurts only when moving',
                orangeAttack: '🟠 ORANGE: Hurts only when still',
                instructLine3: 'Choose your actions wisely during battle!',
                instructLine4: 'Battle will be longer, but your choices will shape the music!',
                instructLine5: 'Press SPACE to continue',
                menuInstructText: 'Use ARROW KEYS to select • Press ENTER to confirm • Click with mouse',
                
                // Attack tips
                attackTips: {
                    'white': 'Move to dodge white attacks!',
                    'green': 'Touch green to heal!',
                    'blue': 'Stand still to avoid blue attacks!',
                    'orange': 'Keep moving to avoid orange attacks!',
                    'mixed': 'Multiple attack types incoming!',
                    'healing': 'Healing opportunities available!'
                },
                
                // Status effects
                catnipHigh: 'Catnip High! ',
                sleepy: 'Sleepy... ',
                emergencyHeals: 'Emergency Heals: ',
                
                // Endings
                victoryTitle: '✨ VICTORY ✨',
                gameoverTitle: '💀 GAME OVER 💀',
                restartGame: 'RESTART GAME',
                cutsceneContinue: 'Press SPACE to continue...',
                
                // Battle messages
                itemDestroyed: "* The ITEM button is destroyed... you can't use items anymore!",
                lastEmergencyHeal: "\n* That was your last emergency heal... Cans looks at you with growing malice!",
                
                // Damage/healing messages
                scratchDamage: (damage, hp) => `* You scratch Cans for ${damage} damage! They look ${hp <= 50 ? 'severely wounded' : 'annoyed but impressed'}.`,
                healMessage: (amount) => `* You use an emergency heal! Restored ${amount} HP. The power of determination fills you.`,
                rageOnlyEmergency: "* In Cans' rage, only emergency heals can help you... but you have none left!",
                treatOffer: "* You offer Cans some treats. They grudgingly accept and seem much less hostile.",
                catnipScatter: "* You scatter catnip around. Cans becomes entranced, and you feel dizzy too!",
                noItems: "* You have no items left! Maybe you should have brought more treats...",
                notReadyMercy: "* Cans is not ready to forgive your trespassing yet. *hisses*",
                warmingUp: "\n* But they seem to be warming up to you...",
                acceptMercy: "* Cans accepts your mercy. They curl up and start purring.",
                
                // Act options
                actOptions: [
                    { text: "* You try to pet Cans. They purr but remain alert.", mood: 'neutral' },
                    { text: "* You make pspsps sounds. Cans looks confused but intrigued.", mood: 'curious' },
                    { text: "* You pretend to ignore Cans. They immediately want attention.", mood: 'attention-seeking' },
                    { text: "* You point at a random spot. Cans looks where you're pointing.", mood: 'distracted' },
                    { text: "* You compliment Cans' beautiful fur. They preen with pride.", mood: 'flattered' },
                    { text: "* You offer to share your lunch. Cans perks up with interest.", mood: 'friendly' }
                ],
                
                // Boss dialogues
                bossDialogues: [
                    "* Cans appears, fur bristling with determination!",
                    "* mrow... you think you can defeat me, human?",
                    "* i've been practicing my zoomies... prepare yourself!",
                    "* time to show you what happens when you disturb my nap...",
                    "* *stretches and yawns* this better be worth my time",
                    "* wait... do i smell... CATNIP?! *eyes dilate*",
                    "* *sniff sniff* you wouldn't happen to have treats, would you?",
                    "* fine, fine... you're alright for a human i suppose",
                    "* *purrs reluctantly* maybe we can share the sunny spot on the carpet"
                ],
                
                rageDialogues: [
                    "* MROW!! You dare to hurt me?!",
                    "* *fur stands on end* I'll show you true cat fury!",
                    "* You've made a terrible mistake, human...",
                    "* *eyes glow with otherworldly power* Time to get serious!",
                    "* No more playing around... PREPARE FOR MY ULTIMATE FORM!",
                    "* But... I'll give you a chance. Green treats will appear more often now."
                ],
                
                dramaticCutsceneDialogues: [
                    "* mrrow... mrrow... mrrow... mrrow...",
                    "* all right.",
                    "* well, here's a better question.",
                    "* do you wanna have a <span class='dramatic-text'>bad time</span>?",
                    "* 'cause if you take another step forward...",
                    "* you are <span class='dramatic-text'>REALLY</span> not going to like what happens next.",
                    "* ...",
                    "* welp.",
                    "* sorry, old habit.",
                    "* <span class='dramatic-text'>TIME TO GET SERIOUS.</span>"
                ],
                
                itemDestructionDialogues: [
                    "* Cans notices you're out of emergency supplies...",
                    "* *eyes glow with malicious intent*",
                    "* <span class='dramatic-text'>NO MORE ITEMS FOR YOU!</span>",
                    "* *swipes at the ITEM button with supernatural force*",
                    "* <span class='dramatic-text'>CRASH!</span> The button shatters into digital fragments!",
                    "* mrow... now you must face me with only your <span class='dramatic-text'>DETERMINATION</span>!"
                ],
                
                mercyEndingDialogues: [
                    "* Cans stops attacking and looks at you curiously...",
                    "* mrow? you... you're not going to hurt me?",
                    "* *sniffs cautiously* i can sense no hostility in your heart...",
                    "* you know what? i'm tired of fighting too...",
                    "* *purrs softly* maybe we got off on the wrong paw...",
                    "* how about we call it even? you can pet me... just this once...",
                    "* *rolls over dramatically* fine, fine... you win... belly rubs time...",
                    "* from now on, we share the house. deal?",
                    "* *purrs loudly* thanks for showing me that not all humans are terrible...",
                    "* now, where did you say those treats were? *hopeful meow*"
                ],
                
                killEndingDialogues: [
                    "* Cans staggers, breathing heavily...",
                    "* mrow... you're... stronger than i thought...",
                    "* *coughs weakly* why... why did it have to end this way?",
                    "* i just... i just wanted to protect my territory...",
                    "* *looks at you with sad eyes* i hope... i hope you're happy now...",
                    "* maybe... maybe in another life... we could have been friends...",
                    "* *whispers* tell the other cats... tell them i fought bravely...",
                    "* the sunny spot on the carpet... it's yours now...",
                    "* *closes eyes peacefully* thank you for... making it quick...",
                    "* *fades away* take care of yourself... human..."
                ],
                
                playerDeathDialogues: [
                    "* Cans sits triumphantly on your defeated form...",
                    "* *purrs smugly* that's what you get for disturbing my nap!",
                    "* *begins grooming paw* humans... so predictable...",
                    "* *yawns* well, that was a nice warm-up exercise...",
                    "* *curls up for a nap* wake me when the next intruder arrives..."
                ],
                
                attackNames: {
                    'yarnball': 'Yarn Ball Barrage',
                    'fishbone': 'Flying Fishbones',
                    'pawswipe': 'Mighty Paw Swipe',
                    'laser': 'Red Dot Madness',
                    'catnip': 'Catnip Cloud',
                    'zoomies': 'Midnight Zoomies',
                    'mouse': 'Toy Mouse Hunt',
                    'treats': 'Treat Shower',
                    'cardboard': 'Cardboard Fortress',
                    'string': 'String Theory',
                    'hairball': 'Hairball Surprise',
                    'nap': 'Cat Nap Time',
                    'scratching': 'Scratching Post Fury',
                    'hiding': 'Under Furniture',
                    'litter': 'Litter Box Revenge',
                    'blueBones': 'Gravity Well Bones',
                    'orangeZoomies': 'Heat-Seeking Zoomies',
                    'healingTreats': 'Compassionate Treats',
                    'comboAttack': 'Ultimate Cat Combo',
                    'enragedSwipe': 'Enraged Claw Storm',
                    'phaseTransition': 'Tactical Repositioning',
                    'megalovania': 'MEGALO-PAW-NIA',
                    'determination': 'Feline Determination',
                    'mercyHealing': 'Merciful Healing Wave',
                    'emergencyTreats': 'Emergency Treat Supply',
                    'healingWave': 'Healing Wave',
                    'spiralHealing': 'Spiral of Compassion',
                    'healingBurst': 'Compassionate Burst',
                    'flowingHealing': 'Flowing Grace'
                },
                
                feelSleepy: ' (You feel sleepy...)',
                furyDialogue: "* Cans's eyes glow with an otherworldly fury!",
                itemRuinsDialogue: "* The ITEM button lies in ruins... you're on your own now!",
                mercyVictory: "You befriended Cans! The power of mercy has triumphed!",
                killVictory: "You defeated Cans... but at what cost?",
                deathMessage: "Better luck next time! Cans remains undefeated."
            },
            
            zh: {
                // UI Elements
                hp: '生命值',
                bossHP: 'Cans 生命值',
                phase: '階段',
                attack: '攻擊',
                tip: '提示',
                preparing: '準備中...',
                mute: '🔊 靜音',
                unmute: '🔇 取消靜音',
                vol: '音量：',
                ready: '就緒',
                loading: '載入中',
                error: '錯誤',
                playing: '播放中',
                paused: '已暫停',
                clickToPlay: '點擊播放',
                seriousMode: '♪ 認真模式 ♪',
                rageModeActive: '狂暴模式啟動！',
                languageHint: '按空白鍵或 ENTER 切換語言',
                
                // Menu buttons
                fight: '戰鬥',
                act: '行動',
                item: '物品',
                mercy: '仁慈',
                destroyed: '已毀壞',
                destroyedMessage: '✗ 已毀壞 ✗',
                
                // Game title and instructions
                gameTitle: '🐱 Cans - 終極貓咪 🐱',
                instructLine1: '使用方向鍵或 WASD 移動你的心並躲避攻擊！',
                instructLine2: '不同顏色的攻擊有特殊效果：',
                whiteAttack: '⚪ 白色：觸碰會受傷',
                greenAttack: '🟢 綠色：觸碰會回血',
                blueAttack: '🔵 藍色：只在移動時受傷',
                orangeAttack: '🟠 橘色：只在靜止時受傷',
                instructLine3: '在戰鬥中明智地選擇你的行動！',
                instructLine4: '戰鬥會更長，但你的選擇將塑造音樂！',
                instructLine5: '按空白鍵繼續',
                menuInstructText: '使用方向鍵選擇 • 按 ENTER 確認 • 可用滑鼠點擊',
                
                // Attack tips
                attackTips: {
                    'white': '移動來躲避白色攻擊！',
                    'green': '觸碰綠色來回血！',
                    'blue': '保持靜止以避免藍色攻擊！',
                    'orange': '保持移動以避免橘色攻擊！',
                    'mixed': '多種攻擊類型來襲！',
                    'healing': '治療機會出現！'
                },
                
                // Status effects
                catnipHigh: '貓薄荷上頭！',
                sleepy: '昏昏欲睡...',
                emergencyHeals: '緊急治療：',
                
                // Endings
                victoryTitle: '✨ 勝利 ✨',
                gameoverTitle: '💀 遊戲結束 💀',
                restartGame: '重新開始',
                cutsceneContinue: '按空白鍵繼續...',
                
                // Battle messages
                itemDestroyed: "* 物品按鈕已被摧毀...你無法再使用物品了！",
                lastEmergencyHeal: "\n* 那是你最後的緊急治療...Cans 帶著越來越大的惡意看著你！",
                
                // Damage/healing messages
                scratchDamage: (damage, hp) => `* 你抓傷 Cans 造成 ${damage} 點傷害！他們看起來${hp <= 50 ? '嚴重受傷' : '惱怒但印象深刻'}。`,
                healMessage: (amount) => `* 你使用了緊急治療！恢復 ${amount} 生命值。決心的力量充滿了你。`,
                rageOnlyEmergency: "* 在 Cans 的狂怒中，只有緊急治療能幫助你...但你已經沒有了！",
                treatOffer: "* 你給 Cans 一些零食。他們勉強接受，看起來沒那麼敵對了。",
                catnipScatter: "* 你灑了一些貓薄荷。Cans 變得著迷，你也感到頭暈！",
                noItems: "* 你沒有物品了！也許你應該帶更多零食...",
                notReadyMercy: "* Cans 還沒準備好原諒你的入侵。*嘶嘶聲*",
                warmingUp: "\n* 但他們似乎開始對你有好感了...",
                acceptMercy: "* Cans 接受了你的仁慈。他們蜷縮起來開始打呼嚕。",
                
                // Act options
                actOptions: [
                    { text: "* 你試著撫摸 Cans。他們發出呼嚕聲但保持警惕。", mood: 'neutral' },
                    { text: "* 你發出 pspsps 的聲音。Cans 看起來困惑但感興趣。", mood: 'curious' },
                    { text: "* 你假裝忽視 Cans。他們立刻想要注意。", mood: 'attention-seeking' },
                    { text: "* 你指向一個隨機的地方。Cans 看向你指的地方。", mood: 'distracted' },
                    { text: "* 你稱讚 Cans 美麗的毛髮。他們驕傲地整理毛髮。", mood: 'flattered' },
                    { text: "* 你提議分享你的午餐。Cans 興致勃勃地豎起耳朵。", mood: 'friendly' }
                ],
                
                // Boss dialogues
                bossDialogues: [
                    "* Cans 出現了，毛髮因決心而豎起！",
                    "* 喵嗚...你以為你能打敗我嗎，人類？",
                    "* 我一直在練習我的瘋狂衝刺...準備好吧！",
                    "* 是時候讓你知道打擾我午睡的後果了...",
                    "* *伸懶腰並打哈欠* 這最好值得我的時間",
                    "* 等等...我聞到...貓薄荷的味道嗎？！*瞳孔放大*",
                    "* *嗅嗅* 你不會剛好有零食吧？",
                    "* 好吧，好吧...對一個人類來說你還不錯",
                    "* *勉強地發出呼嚕聲* 也許我們可以分享地毯上的陽光點"
                ],
                
                rageDialogues: [
                    "* 喵嗚！！你竟敢傷害我？！",
                    "* *毛髮豎立* 我會讓你見識真正的貓之憤怒！",
                    "* 你犯了個可怕的錯誤，人類...",
                    "* *眼睛發出超自然的光芒* 是時候認真了！",
                    "* 不再玩耍了...準備迎接我的終極形態！",
                    "* 但是...我會給你一個機會。綠色零食會更頻繁地出現。"
                ],
                
                dramaticCutsceneDialogues: [
                    "* 喵嗚...喵嗚...喵嗚...喵嗚...",
                    "* 好吧。",
                    "* 嗯，這裡有個更好的問題。",
                    "* 你想要有個<span class='dramatic-text'>糟糕的時光</span>嗎？",
                    "* 因為如果你再往前走一步...",
                    "* 你<span class='dramatic-text'>真的</span>不會喜歡接下來發生的事。",
                    "* ...",
                    "* 唉呀。",
                    "* 抱歉，老習慣了。",
                    "* <span class='dramatic-text'>是時候認真起來了。</span>"
                ],
                
                itemDestructionDialogues: [
                    "* Cans 注意到你的緊急補給用完了...",
                    "* *眼睛發出惡意的光芒*",
                    "* <span class='dramatic-text'>你再也沒有物品了！</span>",
                    "* *用超自然的力量揮向物品按鈕*",
                    "* <span class='dramatic-text'>轟！</span>按鈕碎成了數位碎片！",
                    "* 喵嗚...現在你必須只憑你的<span class='dramatic-text'>決心</span>面對我！"
                ],
                
                mercyEndingDialogues: [
                    "* Cans 停止攻擊，好奇地看著你...",
                    "* 喵嗚？你...你不會傷害我？",
                    "* *謹慎地嗅聞* 我感覺不到你心中的敵意...",
                    "* 你知道嗎？我也累了不想打了...",
                    "* *輕聲呼嚕* 也許我們一開始就搞錯了...",
                    "* 我們和解如何？你可以摸我...就這一次...",
                    "* *戲劇性地翻滾* 好吧，好吧...你贏了...揉肚子時間到了...",
                    "* 從現在開始，我們共享這個房子。成交？",
                    "* *大聲呼嚕* 謝謝你讓我知道不是所有人類都很糟糕...",
                    "* 現在，你說那些零食在哪裡？*充滿希望的喵叫*"
                ],
                
                killEndingDialogues: [
                    "* Cans 搖搖晃晃，呼吸急促...",
                    "* 喵嗚...你...比我想的還要強...",
                    "* *虛弱地咳嗽* 為什麼...為什麼要這樣結束？",
                    "* 我只是...我只是想保護我的領土...",
                    "* *用悲傷的眼神看著你* 我希望...我希望你現在開心了...",
                    "* 也許...也許在另一個生命裡...我們可以成為朋友...",
                    "* *低聲說* 告訴其他貓咪...告訴他們我勇敢地戰鬥過...",
                    "* 地毯上的陽光點...現在是你的了...",
                    "* *平靜地閉上眼睛* 謝謝你...讓它快速結束...",
                    "* *漸漸消失* 照顧好自己...人類..."
                ],
                
                playerDeathDialogues: [
                    "* Cans 得意地坐在你被擊敗的身體上...",
                    "* *得意地呼嚕* 這就是打擾我午睡的下場！",
                    "* *開始整理爪子* 人類...太容易預測了...",
                    "* *打哈欠* 嗯，那是個不錯的熱身運動...",
                    "* *蜷縮起來小睡* 下一個入侵者來的時候叫醒我..."
                ],
                
                attackNames: {
                    'yarnball': '毛線球彈幕',
                    'fishbone': '飛行魚骨',
                    'pawswipe': '強力貓掌揮擊',
                    'laser': '紅點瘋狂',
                    'catnip': '貓薄荷雲',
                    'zoomies': '午夜瘋狂衝刺',
                    'mouse': '玩具老鼠狩獵',
                    'treats': '零食雨',
                    'cardboard': '紙箱堡壘',
                    'string': '弦理論',
                    'hairball': '毛球驚喜',
                    'nap': '貓咪午睡時間',
                    'scratching': '貓抓板狂怒',
                    'hiding': '傢俱下躲藏',
                    'litter': '貓砂盆復仇',
                    'blueBones': '重力井骨頭',
                    'orangeZoomies': '熱追蹤瘋狂衝刺',
                    'healingTreats': '慈悲零食',
                    'comboAttack': '終極貓咪連擊',
                    'enragedSwipe': '狂怒爪風暴',
                    'phaseTransition': '戰術重新定位',
                    'megalovania': '巨大貓掌曲',
                    'determination': '貓科決心',
                    'mercyHealing': '仁慈治療波',
                    'emergencyTreats': '緊急零食補給',
                    'healingWave': '治療波',
                    'spiralHealing': '慈悲螺旋',
                    'healingBurst': '慈悲爆發',
                    'flowingHealing': '流動恩典'
                },
                
                feelSleepy: '（你感到昏昏欲睡...）',
                furyDialogue: "* Cans 的眼睛發出超凡脫俗的怒火！",
                itemRuinsDialogue: "* 物品按鈕成了廢墟...你現在只能靠自己了！",
                mercyVictory: "你和 Cans 成為了朋友！仁慈的力量取得了勝利！",
                killVictory: "你打敗了 Cans...但代價是什麼？",
                deathMessage: "下次好運！Cans 依然不敗。"
            }
        };
        
        // Get translation function
        function t(key, ...args) {
            const keys = key.split('.');
            let value = translations[currentLanguage];
            
            for (const k of keys) {
                value = value[k];
                if (!value) return key;
            }
            
            if (typeof value === 'function') {
                return value(...args);
            }
            
            return value;
        }
        
        // Update UI text
        function updateUILanguage() {
            // Update static text elements
            document.getElementById('hpLabel').textContent = t('hp');
            document.getElementById('bossHPLabel').textContent = t('bossHP');
            document.getElementById('phaseLabel').textContent = t('phase');
            document.getElementById('attackLabel').textContent = t('attack');
            document.getElementById('tipLabel').textContent = t('tip');
            document.getElementById('gameTitle').textContent = t('gameTitle');
            document.getElementById('instructLine1').textContent = t('instructLine1');
            document.getElementById('instructLine2').textContent = t('instructLine2');
            document.getElementById('whiteAttack').textContent = t('whiteAttack');
            document.getElementById('greenAttack').textContent = t('greenAttack');
            document.getElementById('blueAttack').textContent = t('blueAttack');
            document.getElementById('orangeAttack').textContent = t('orangeAttack');
            document.getElementById('instructLine3').textContent = t('instructLine3');
            document.getElementById('instructLine4').textContent = t('instructLine4');
            document.getElementById('instructLine5').textContent = t('instructLine5');
            document.getElementById('languageHint').textContent = t('languageHint');
            document.getElementById('menuInstructText').textContent = t('menuInstructText');
            document.getElementById('fightBtn').textContent = t('fight');
            document.getElementById('actBtn').textContent = t('act');
            document.getElementById('itemBtn').textContent = boss.itemButtonDestroyed ? t('destroyed') : t('item');
            document.getElementById('mercyBtn').textContent = t('mercy');
            document.getElementById('restartButton').textContent = t('restartGame');
            document.getElementById('cutsceneContinue').textContent = t('cutsceneContinue');
            document.getElementById('victoryTitle').textContent = t('victoryTitle');
            document.getElementById('gameoverTitle').textContent = t('gameoverTitle');
            document.getElementById('rageModeIndicator').textContent = t('rageModeActive');
            
            // Update volume label
            const volLabel = document.querySelector('.volume-control span');
            if (volLabel) volLabel.textContent = t('vol');
            
            // Update music toggle
            const musicToggle = document.getElementById('musicToggle');
            if (musicToggle) {
                musicToggle.textContent = musicMuted ? t('unmute') : t('mute');
            }
            
            // Update audio status
            const audioStatus = document.getElementById('audioStatus');
            if (audioStatus) {
                const statusText = audioStatus.textContent;
                if (statusText === 'READY') audioStatus.textContent = t('ready');
                else if (statusText === 'LOADING') audioStatus.textContent = t('loading');
                else if (statusText === 'ERROR') audioStatus.textContent = t('error');
                else if (statusText === 'PLAYING') audioStatus.textContent = t('playing');
                else if (statusText === 'PAUSED') audioStatus.textContent = t('paused');
                else if (statusText === 'CLICK TO PLAY') audioStatus.textContent = t('clickToPlay');
            }
            
            // Update current attack display
            if (currentAttackSpan.textContent === 'Preparing...') {
                currentAttackSpan.textContent = t('preparing');
            }
            
            // Update language button
            document.getElementById('languageBtn').textContent = currentLanguage === 'en' ? '中文' : 'English';
        }
        
        // Language toggle handler
        document.getElementById('languageBtn').addEventListener('click', () => {
            currentLanguage = currentLanguage === 'en' ? 'zh' : 'en';
            updateUILanguage();
            
            // Update current attack tip if displayed
            if (attackTypeIndicator.style.display !== 'none') {
                const currentTipKey = Object.keys(t('attackTips')).find(key => 
                    translations.en.attackTips[key] === attackTip.textContent
                );
                if (currentTipKey) {
                    attackTip.textContent = t('attackTips')[currentTipKey];
                }
            }
        });
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dialogue = document.getElementById('dialogue');
        const dialogueText = document.getElementById('dialogueText');
        const menu = document.getElementById('menu');
        const menuInstructions = document.getElementById('menuInstructions');
        const instructions = document.getElementById('instructions');
        const playerHPSpan = document.getElementById('playerHP');
        const bossHPSpan = document.getElementById('bossHP');
        const attackInfo = document.getElementById('attackInfo');
        const currentPhaseSpan = document.getElementById('currentPhase');
        const currentAttackSpan = document.getElementById('currentAttack');
        const statusEffect = document.getElementById('statusEffect');
        const endingOverlay = document.getElementById('endingOverlay');
        const victoryText = document.getElementById('victoryText');
        const gameoverText = document.getElementById('gameoverText');
        const victoryMessage = document.getElementById('victoryMessage');
        const gameoverMessage = document.getElementById('gameoverMessage');
        const restartButton = document.getElementById('restartButton');
        const attackTypeIndicator = document.getElementById('attackTypeIndicator');
        const attackTip = document.getElementById('attackTip');
        const musicIndicator = document.getElementById('musicIndicator');
        const currentTrack = document.getElementById('currentTrack');
        const rageModeIndicator = document.getElementById('rageModeIndicator');
        
        // Cutscene elements
        const cutsceneOverlay = document.getElementById('cutsceneOverlay');
        const cutsceneDialogue = document.getElementById('cutsceneDialogue');
        const cutsceneText = document.getElementById('cutsceneText');
        const screenFlash = document.getElementById('screenFlash');
        
        // Audio elements
        const backgroundMusic = document.getElementById('backgroundMusic');
        const rageMusic = document.getElementById('rageMusic');
        const musicToggle = document.getElementById('musicToggle');
        const volumeSlider = document.getElementById('volumeSlider');
        const audioStatus = document.getElementById('audioStatus');
        
        // Audio state
        let musicPlaying = false;
        let musicMuted = false;
        let currentMusic = backgroundMusic;
        let musicPath = 'neutral'; // 'neutral', 'mercy', 'genocide'
        
        // Game state
        let gameState = 'intro'; // intro, menu, attack, dialogue, win, gameover, ending, death_animation, mercy_ending, kill_ending, cutscene
        let player = { 
            x: 400, 
            y: 300, 
            size: 8, 
            hp: 20, 
            maxHP: 20,
            statusEffects: {},
            isMoving: false,
            lastPosition: { x: 400, y: 300 },
            invincibilityTimer: 0,
            invincibilityDuration: 60 // 1 second at 60fps
        };
        let boss = { 
            hp: 250, 
            maxHP: 250, 
            phase: 0, 
            mood: 'aggressive',
            deathTimer: 0,
            opacity: 1.0,
            scale: 1.0,
            deathEffects: [],
            attackPatterns: [],
            lastAttackTime: 0,
            consecutiveAttacks: 0,
            enragedMode: false,
            musicTriggered: false,
            fightCount: 0,
            mercyAttempts: 0,
            rageHealingBonus: false,
            cutsceneTriggered: false,
            itemButtonDestroyed: false,
            emergencyHealsUsed: 0 // Track emergency heals used
        };
        let attacks = [];
        let particles = [];
        let keys = {};
        let selectedMenuItem = 0;
        let battleBox = { x: 150, y: 200, width: 500, height: 200 };
        let attackTimer = 0;
        let currentAttackType = '';
        let turnCounter = 0;
        let playerItems = { treats: 3, catnip: 1, emergencyHeal: 0 };
        let actionSelected = false;
        let endingDialogueIndex = 0;
        let endingType = 'none'; // 'mercy', 'kill'
        let playerDeathTimer = 0;
        let attackPhaseTimer = 0;
        let gameLoopId = null;
        let cutsceneStep = 0;
        
        // Attack pattern counters for fixed patterns
        let attackPatternCounters = {
            yarnball: 0,
            fishbone: 0,
            blueBones: 0,
            orangeZoomies: 0,
            string: 0,
            scratching: 0,
            healingPattern: 0
        };
        
        // Enhanced clearing functions
        function forceCompleteClearing() {
            console.log("🧹 FORCE COMPLETE CLEARING");
            
            // Clear arrays completely
            attacks.splice(0, attacks.length);
            particles.splice(0, particles.length);
            
            // Force clear canvas with multiple passes
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
            
            // Reset timers
            attackTimer = 0;
            attackPhaseTimer = 0;
            
            console.log("✅ Complete clearing finished");
        }
        
        function clearGameVisuals() {
            console.log("🧹 Clearing game visuals");
            
            // Hide all UI elements
            menu.style.display = 'none';
            menuInstructions.style.display = 'none';
            dialogue.style.display = 'none';
            attackInfo.style.display = 'none';
            attackTypeIndicator.style.display = 'none';
            
            // Force complete clearing
            forceCompleteClearing();
        }
        
        // Audio Functions
        function initializeAudio() {
            backgroundMusic.volume = volumeSlider.value / 100;
            rageMusic.volume = volumeSlider.value / 100;
            
            // Initialize both audio tracks
            [backgroundMusic, rageMusic].forEach(audio => {
                audio.addEventListener('loadstart', () => {
                    if (audio === currentMusic) {
                        audioStatus.textContent = t('loading');
                        audioStatus.style.color = '#ffff00';
                    }
                });
                
                audio.addEventListener('canplay', () => {
                    if (audio === currentMusic) {
                        audioStatus.textContent = t('ready');
                        audioStatus.style.color = '#00ff00';
                    }
                });
                
                audio.addEventListener('error', (e) => {
                    if (audio === currentMusic) {
                        audioStatus.textContent = t('error');
                        audioStatus.style.color = '#ff0000';
                        console.error('Audio error:', e);
                    }
                });
                
                audio.addEventListener('play', () => {
                    if (audio === currentMusic) {
                        musicPlaying = true;
                        audioStatus.textContent = t('playing');
                        audioStatus.style.color = '#00ff00';
                    }
                });
                
                audio.addEventListener('pause', () => {
                    if (audio === currentMusic) {
                        musicPlaying = false;
                        audioStatus.textContent = t('paused');
                        audioStatus.style.color = '#ffff00';
                    }
                });
            });
        }

        // Cutscene Functions
        function triggerDramaticCutscene() {
            if (boss.cutsceneTriggered) return;
            boss.cutsceneTriggered = true;
            
            gameState = 'cutscene';
            cutsceneStep = 0;
            
            // Force complete clearing
            forceCompleteClearing();
            clearGameVisuals();
            
            // Start the cutscene
            showCutsceneDialogue();
        }

        function triggerItemDestructionCutscene() {
            console.log("🎭 TRIGGERING ITEM DESTRUCTION CUTSCENE!");
            
            if (boss.itemButtonDestroyed) {
                console.log("Button already destroyed, skipping cutscene");
                return;
            }
            
            // IMMEDIATELY mark button as destroyed to prevent any further usage
            boss.itemButtonDestroyed = true;
            destroyItemButtonVisually(); // Apply visual destruction immediately
            
            gameState = 'item_destruction_cutscene';
            cutsceneStep = 0;
            
            // Force complete clearing
            forceCompleteClearing();
            clearGameVisuals();
            
            // Start the item destruction cutscene
            showItemDestructionCutscene();
        }

        function showItemDestructionCutscene() {
            cutsceneOverlay.style.display = 'flex';
            
            const dialogues = t('itemDestructionDialogues');
            
            if (cutsceneStep < dialogues.length) {
                const dialogue = dialogues[cutsceneStep];
                cutsceneText.innerHTML = dialogue;
                
                // Add special effects for dramatic moments
                if (dialogue.includes('NO MORE ITEMS') || dialogue.includes('CRASH') || dialogue.includes('DETERMINATION') ||
                    dialogue.includes('沒有物品') || dialogue.includes('轟') || dialogue.includes('決心')) {
                    flashScreen();
                    shakeScreen();
                }
                
                // Change text color for dramatic lines
                if (dialogue.includes('NO MORE ITEMS') || dialogue.includes('DETERMINATION') ||
                    dialogue.includes('沒有物品') || dialogue.includes('決心')) {
                    cutsceneText.style.color = '#ff0000';
                } else if (dialogue.includes('CRASH') || dialogue.includes('轟')) {
                    cutsceneText.style.color = '#ff4500';
                } else {
                    cutsceneText.style.color = '#fff';
                }
            }
        }

        function destroyItemButtonVisually() {
            const itemButton = document.querySelector('[data-action="item"]');
            console.log('🔥 DESTROYING BUTTON VISUALLY:', itemButton);
            
            if (itemButton) {
                // FORCE DESTRUCTION STATE
                itemButton.classList.add('destroyed');
                
                // Override all styles to ensure destruction is visible
                itemButton.style.setProperty('background', '#1a0000', 'important');
                itemButton.style.setProperty('color', '#333', 'important');
                itemButton.style.setProperty('border-color', '#333', 'important');
                itemButton.style.setProperty('transform', 'rotate(-5deg) scale(0.8)', 'important');
                itemButton.style.setProperty('opacity', '0.3', 'important');
                itemButton.style.setProperty('cursor', 'not-allowed', 'important');
                itemButton.style.setProperty('pointer-events', 'none', 'important');
                
                // Change text content
                itemButton.innerHTML = `<span style="color: #ff0000; font-weight: bold;">${t('destroyed')}</span>`;
                
                // Update the ::before pseudo-element content
                const style = document.createElement('style');
                style.textContent = `.menu-button.destroyed::before { content: '✗ ${t('destroyedMessage')} ✗' !important; }`;
                document.head.appendChild(style);
                
                // Create destruction particle explosion - reduced number
                for (let i = 0; i < 15; i++) {
                    particles.push({
                        type: 'destruction',
                        x: 400 + (Math.random() - 0.5) * 100,
                        y: 500 + (Math.random() - 0.5) * 60,
                        dx: (Math.random() - 0.5) * 6,
                        dy: (Math.random() - 0.5) * 6 - 2,
                        timer: 90,
                        color: Math.random() < 0.5 ? '#ff0000' : '#ffff00',
                        size: Math.random() * 3 + 2
                    });
                }
                
                // Add screen shake effect - simplified
                let shakeCount = 0;
                const shakeInterval = setInterval(() => {
                    document.getElementById('gameContainer').style.transform = 
                        `translate(${(Math.random() - 0.5) * 4}px, ${(Math.random() - 0.5) * 4}px)`;
                    shakeCount++;
                    
                    if (shakeCount > 8) {
                        clearInterval(shakeInterval);
                        document.getElementById('gameContainer').style.transform = 'translate(0px, 0px)';
                    }
                }, 50);
                
                console.log('✅ BUTTON DESTRUCTION COMPLETE');
            } else {
                console.log('❌ Item button not found!');
            }
        }

        function nextItemDestructionDialogue() {
            cutsceneStep++;
            
            const dialogues = t('itemDestructionDialogues');
            if (cutsceneStep >= dialogues.length) {
                endItemDestructionCutscene();
            } else {
                showItemDestructionCutscene();
            }
        }

        function endItemDestructionCutscene() {
            cutsceneOverlay.style.display = 'none';
            
            // Show UI elements again
            attackInfo.style.display = 'block';
            rageModeIndicator.style.display = 'block';
            
            // Continue with the game
            gameState = 'dialogue';
            showDialogue(t('itemRuinsDialogue'));
        }
        
        function showCutsceneDialogue() {
            cutsceneOverlay.style.display = 'flex';
            
            const dialogues = gameState === 'item_destruction_cutscene' ? t('itemDestructionDialogues') : t('dramaticCutsceneDialogues');
            
            if (cutsceneStep < dialogues.length) {
                const dialogue = dialogues[cutsceneStep];
                cutsceneText.innerHTML = dialogue;
                
                // Add special effects for dramatic moments
                if (dialogue.includes('bad time') || dialogue.includes('REALLY') || dialogue.includes('SERIOUS') ||
                    dialogue.includes('NO MORE ITEMS') || dialogue.includes('CRASH') || dialogue.includes('DETERMINATION') ||
                    dialogue.includes('糟糕的時光') || dialogue.includes('真的') || dialogue.includes('認真') ||
                    dialogue.includes('沒有物品') || dialogue.includes('轟') || dialogue.includes('決心')) {
                    flashScreen();
                    shakeScreen();
                }
                
                // Change text color for dramatic lines
                if (dialogue.includes('SERIOUS') || dialogue.includes('NO MORE ITEMS') || dialogue.includes('DETERMINATION') ||
                    dialogue.includes('認真') || dialogue.includes('沒有物品') || dialogue.includes('決心')) {
                    cutsceneText.style.color = '#ff0000';
                } else if (dialogue.includes('bad time') || dialogue.includes('CRASH') ||
                          dialogue.includes('糟糕的時光') || dialogue.includes('轟')) {
                    cutsceneText.style.color = '#ff4500';
                } else {
                    cutsceneText.style.color = '#fff';
                }
            }
        }
        
        function nextCutsceneDialogue() {
            cutsceneStep++;
            
            if (gameState === 'item_destruction_cutscene') {
                const dialogues = t('itemDestructionDialogues');
                if (cutsceneStep >= dialogues.length) {
                    endItemDestructionCutscene();
                } else {
                    showItemDestructionCutscene();
                }
            } else {
                const dialogues = t('dramaticCutsceneDialogues');
                if (cutsceneStep >= dialogues.length) {
                    endCutscene();
                } else {
                    showCutsceneDialogue();
                }
            }
        }
        
        function endCutscene() {
            cutsceneOverlay.style.display = 'none';
            
            // Activate rage mode
            boss.mood = 'enraged';
            boss.enragedMode = true;
            
            if (musicPath === 'genocide') {
                switchToRageMusic();
            }
            
            // Show UI elements again
            attackInfo.style.display = 'block';
            rageModeIndicator.style.display = 'block';
            
            // Continue with the game
            gameState = 'dialogue';
            showDialogue(t('furyDialogue'));
        }
        
        function flashScreen() {
            screenFlash.style.opacity = '0.5';
            setTimeout(() => {
                screenFlash.style.opacity = '0';
            }, 100);
        }
        
        function shakeScreen() {
            document.getElementById('gameContainer').classList.add('screen-shake');
            setTimeout(() => {
                document.getElementById('gameContainer').classList.remove('screen-shake');
            }, 500);
        }

        function switchToRageMusic() {
            if (!boss.musicTriggered && musicPath === 'genocide') {
                boss.musicTriggered = true;
                boss.rageHealingBonus = true; // Enable extra healing in rage mode
                rageModeIndicator.style.display = 'block';
                
                // Add emergency heals for rage mode
                playerItems.emergencyHeal = 2;
                boss.emergencyHealsUsed = 0; // Reset counter
                
                const currentVolume = currentMusic.volume;
                
                // Fade out current music
                fadeOutMusic(1000, currentMusic);
                
                // Switch to rage music
                setTimeout(() => {
                    currentMusic = rageMusic;
                    currentMusic.volume = 0;
                    currentTrack.textContent = t('seriousMode');
                    currentTrack.style.color = '#ff0000';
                    musicIndicator.style.animation = 'pulse 1s infinite';
                    
                    if (!musicMuted) {
                        currentMusic.play().then(() => {
                            // Fade in rage music
                            const fadeStep = currentVolume / 20;
                            const fadeInterval = setInterval(() => {
                                if (currentMusic.volume < currentVolume) {
                                    currentMusic.volume = Math.min(currentVolume, currentMusic.volume + fadeStep);
                                } else {
                                    clearInterval(fadeInterval);
                                }
                            }, 50);
                        }).catch(error => {
                            console.log('Error playing rage music:', error);
                        });
                    }
                }, 1000);
            }
        }
        
        function startMusic() {
            if (!musicMuted && currentMusic.readyState >= 2) {
                const playPromise = currentMusic.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('Music started successfully');
                    }).catch(error => {
                        console.log('Auto-play was prevented:', error);
                        audioStatus.textContent = t('clickToPlay');
                        audioStatus.style.color = '#ff0000';
                    });
                }
            }
        }
        
        function stopMusic() {
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
            rageMusic.pause();
            rageMusic.currentTime = 0;
        }
        
        function toggleMusic() {
            musicMuted = !musicMuted;
            if (musicMuted) {
                currentMusic.pause();
                musicToggle.textContent = t('unmute');
                audioStatus.textContent = t('paused');
                audioStatus.style.color = '#ff0000';
            } else {
                startMusic();
                musicToggle.textContent = t('mute');
            }
        }
        
        function updateVolume() {
            backgroundMusic.volume = volumeSlider.value / 100;
            rageMusic.volume = volumeSlider.value / 100;
        }
        
        function fadeOutMusic(duration = 2000, targetMusic = null) {
            const music = targetMusic || currentMusic;
            const startVolume = music.volume;
            const fadeStep = startVolume / (duration / 50);
            
            const fadeInterval = setInterval(() => {
                if (music.volume > 0) {
                    music.volume = Math.max(0, music.volume - fadeStep);
                } else {
                    clearInterval(fadeInterval);
                    music.pause();
                }
            }, 50);
        }
        
        function fadeInMusic(duration = 2000) {
            const targetVolume = volumeSlider.value / 100;
            currentMusic.volume = 0;
            if (!musicMuted) {
                startMusic();
                const fadeStep = targetVolume / (duration / 50);
                
                const fadeInterval = setInterval(() => {
                    if (currentMusic.volume < targetVolume) {
                        currentMusic.volume = Math.min(targetVolume, currentMusic.volume + fadeStep);
                    } else {
                        clearInterval(fadeInterval);
                    }
                }, 50);
            }
        }
        
        // Audio Control Event Listeners
        musicToggle.addEventListener('click', toggleMusic);
        volumeSlider.addEventListener('input', updateVolume);
        
        // Initialize audio when page loads
        initializeAudio();
        
        // Restart functionality
        restartButton.addEventListener('click', () => {
            resetGame();
        });

        function resetGame() {
            // Cancel existing game loop
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            // Force complete clearing first
            forceCompleteClearing();
            
            // Reset all game state
            gameState = 'intro';
            player = { 
                x: 400, 
                y: 300, 
                size: 8, 
                hp: 20, 
                maxHP: 20,
                statusEffects: {},
                isMoving: false,
                lastPosition: { x: 400, y: 300 },
                invincibilityTimer: 0,
                invincibilityDuration: 60
            };
            boss = { 
                hp: 250, 
                maxHP: 250, 
                phase: 0, 
                mood: 'aggressive',
                deathTimer: 0,
                opacity: 1.0,
                scale: 1.0,
                deathEffects: [],
                attackPatterns: [],
                lastAttackTime: 0,
                consecutiveAttacks: 0,
                enragedMode: false,
                musicTriggered: false,
                fightCount: 0,
                mercyAttempts: 0,
                rageHealingBonus: false,
                cutsceneTriggered: false,
                itemButtonDestroyed: false,
                emergencyHealsUsed: 0
            };
            selectedMenuItem = 0;
            attackTimer = 0;
            currentAttackType = '';
            turnCounter = 0;
            playerItems = { treats: 3, catnip: 1, emergencyHeal: 0 };
            actionSelected = false;
            endingDialogueIndex = 0;
            endingType = 'none';
            playerDeathTimer = 0;
            attackPhaseTimer = 0;
            musicPath = 'neutral';
            cutsceneStep = 0;
            frameCount = 0;

            // Reset attack pattern counters
            attackPatternCounters = {
                yarnball: 0,
                fishbone: 0,
                blueBones: 0,
                orangeZoomies: 0,
                string: 0,
                scratching: 0,
                healingPattern: 0
            };

            // Clear arrays completely
            attacks.splice(0, attacks.length);
            particles.splice(0, particles.length);
            keys = {};

            // Multiple canvas clearing passes
            for (let i = 0; i < 3; i++) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Hide ALL UI elements first
            endingOverlay.style.display = 'none';
            victoryText.style.display = 'none';
            gameoverText.style.display = 'none';
            dialogue.style.display = 'none';
            menu.style.display = 'none';
            menu.style.pointerEvents = 'auto'; // Re-enable menu interactions
            menuInstructions.style.display = 'none';
            attackInfo.style.display = 'none'; // Hide attack info on restart
            attackTypeIndicator.style.display = 'none';
            rageModeIndicator.style.display = 'none';
            cutsceneOverlay.style.display = 'none';
            
            // Reset menu selection and restore ITEM button
            const buttons = document.querySelectorAll('.menu-button');
            buttons.forEach((button, index) => {
                button.classList.remove('selected', 'destroyed');
                
                // Specifically restore ITEM button
                if (index === 2) { // ITEM button
                    button.innerHTML = t('item');
                    // Clear all forced styles
                    button.style.cssText = '';
                    button.removeAttribute('style');
                }
            });
            
            // Show instructions
            instructions.style.display = 'block';
            
            // Reset phase and attack displays
            currentPhaseSpan.textContent = '1';
            currentAttackSpan.textContent = t('preparing');
            attackTip.textContent = t('attackTips.white');

            // Reset audio
            stopMusic();
            currentMusic = backgroundMusic;
            currentTrack.textContent = '♪ Last Goodbye ♪';
            currentTrack.style.color = '#ff69b4';
            musicIndicator.style.animation = 'none';
            volumeSlider.value = 50;
            updateVolume();
            musicMuted = false;
            musicToggle.textContent = t('mute');

            // Update stats display
            updateStats();
            
            // Clear any status effects display
            statusEffect.textContent = '';
            
            // Reset screen effects
            document.getElementById('gameContainer').classList.remove('screen-shake');
            screenFlash.style.opacity = '0';
            
            // Update UI language
            updateUILanguage();
            
            // Restart game loop
            gameLoop();
        }
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            // Block all input during win/gameover states except restart
            if (gameState === 'win' || gameState === 'gameover' || gameState === 'player_death' || gameState === 'death_animation') {
                return;
            }
            
            keys[e.key.toLowerCase()] = true;
            
            // Toggle language with Space or Enter in intro screen
            if (gameState === 'intro' && (e.code === 'Space' || e.code === 'Enter')) {
                // If Space is pressed and Shift is not held, start the game
                // If Enter is pressed or Space+Shift is pressed, toggle language
                if (e.code === 'Space' && !e.shiftKey) {
                    startGame();
                } else {
                    currentLanguage = currentLanguage === 'en' ? 'zh' : 'en';
                    updateUILanguage();
                }
                e.preventDefault();
            }
            else if ((gameState === 'dialogue' || gameState === 'ending') && e.code === 'Space') {
                if (gameState === 'dialogue') {
                    nextDialogue();
                } else if (gameState === 'ending') {
                    nextEndingDialogue();
                }
                e.preventDefault();
            }
            else if ((gameState === 'cutscene' || gameState === 'item_destruction_cutscene') && e.code === 'Space') {
                nextCutsceneDialogue();
                e.preventDefault();
            }
            else if (gameState === 'menu' && e.key === 'Enter') {
                selectMenuItem();
                e.preventDefault();
            }
            else if (gameState === 'menu') {
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'ArrowUp' || e.key === 'w') {
                    let newSelection = selectedMenuItem - 1;
                    
                    // Skip destroyed item button
                    if (newSelection === 2 && boss.itemButtonDestroyed) {
                        newSelection--;
                    }
                    
                    if (newSelection >= 0) {
                        selectedMenuItem = newSelection;
                        updateMenuSelection();
                    }
                    e.preventDefault();
                } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'ArrowDown' || e.key === 's') {
                    let newSelection = selectedMenuItem + 1;
                    
                    // Skip destroyed item button
                    if (newSelection === 2 && boss.itemButtonDestroyed) {
                        newSelection++;
                    }
                    
                    if (newSelection <= 3) {
                        selectedMenuItem = newSelection;
                        updateMenuSelection();
                    }
                    e.preventDefault();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            // Clear keys on keyup regardless of game state to prevent stuck keys
            keys[e.key.toLowerCase()] = false;
        });
        
        // Menu handling
        document.querySelectorAll('.menu-button').forEach((button, index) => {
            button.addEventListener('click', (e) => {
                // Block all menu interactions during win/gameover states
                if (gameState === 'win' || gameState === 'gameover' || gameState === 'player_death' || gameState === 'death_animation') {
                    e.preventDefault();
                    return;
                }
                
                if (gameState === 'menu') {
                    // Don't allow clicking destroyed item button
                    if (index === 2 && boss.itemButtonDestroyed) {
                        console.log("🚫 ITEM button is destroyed - click blocked!");
                        showDialogue(t('itemDestroyed'));
                        return;
                    }
                    
                    selectedMenuItem = index;
                    updateMenuSelection();
                    selectMenuItem();
                }
                e.preventDefault();
            });
        });
        
        function updateMenuSelection() {
            const buttons = document.querySelectorAll('.menu-button');
            buttons.forEach((button, index) => {
                if (index === 2 && boss.itemButtonDestroyed) {
                    // Don't allow selection of destroyed item button
                    button.classList.remove('selected');
                } else {
                    button.classList.toggle('selected', index === selectedMenuItem);
                }
            });
        }
        
        function selectMenuItem() {
            // Block all menu actions during end states
            if (gameState === 'win' || gameState === 'gameover' || gameState === 'player_death' || gameState === 'death_animation') {
                return;
            }
            
            if (actionSelected || gameState !== 'menu') return;
            
            const actions = ['fight', 'act', 'item', 'mercy'];
            const action = actions[selectedMenuItem];
            
            // Check if ITEM button is destroyed - ABSOLUTE BLOCK
            if (action === 'item' && boss.itemButtonDestroyed) {
                console.log("🚫 BLOCKED: Attempting to use destroyed ITEM button!");
                showDialogue(t('itemDestroyed'));
                return;
            }
            
            actionSelected = true;
            
            menu.style.display = 'none';
            menuInstructions.style.display = 'none';
            
            let dialogueMessage = '';
            let shouldContinue = true;
            
            switch(action) {
                case 'fight':
                    boss.fightCount++;
                    const damage = Math.floor(Math.random() * 8) + 5; // Reduced from 10-25 to 5-12
                    boss.hp = Math.max(0, boss.hp - damage);
                    dialogueMessage = t('scratchDamage', damage, boss.hp);
                    
                    // Set music path to genocide on first fight
                    if (boss.fightCount === 1 && musicPath === 'neutral') {
                        musicPath = 'genocide';
                    }
                    
                    // Boss gets more aggressive when hurt - trigger cutscene
                    if (boss.hp <= 125 && !boss.enragedMode && !boss.cutsceneTriggered) {
                        // Trigger dramatic cutscene instead of immediate rage mode
                        updateStats();
                        triggerDramaticCutscene();
                        return; // Don't continue with normal dialogue
                    } else if (boss.hp <= 175) {
                        boss.mood = 'annoyed';
                    }
                    break;
                case 'act':
                    const actResult = handleActMenu();
                    dialogueMessage = actResult.text;
                    boss.mood = actResult.mood;
                    break;
                case 'item':
                    dialogueMessage = handleItemMenu();
                    break;
                case 'mercy':
                    boss.mercyAttempts++;
                    if (boss.mercyAttempts === 1 && musicPath === 'neutral') {
                        musicPath = 'mercy';
                    }
                    
                    if (boss.hp < 75 || boss.mood === 'friendly' || boss.mercyAttempts >= 5) {
                        dialogueMessage = t('acceptMercy');
                        endingType = 'mercy';
                        startEnding();
                        shouldContinue = false;
                    } else {
                        dialogueMessage = t('notReadyMercy');
                        if (boss.mercyAttempts >= 3) {
                            dialogueMessage += t('warmingUp');
                            boss.mood = 'curious';
                        }
                    }
                    break;
            }
            
            updateStats();
            
            // Check win condition
            if (boss.hp <= 0) {
                endingType = 'kill';
                startEnding();
                shouldContinue = false;
            }
            
            if (shouldContinue) {
                showDialogue(dialogueMessage);
            }
        }
        
        function handleActMenu() {
            const actOptions = t('actOptions');
            return actOptions[Math.floor(Math.random() * actOptions.length)];
        }
        
        function handleItemMenu() {
            console.log("🎒 ITEM MENU - Checking states:");
            console.log("- Enraged Mode:", boss.enragedMode);
            console.log("- Item Button Destroyed:", boss.itemButtonDestroyed);
            console.log("- Emergency Heals:", playerItems.emergencyHeal);
            console.log("- Emergency Heals Used:", boss.emergencyHealsUsed);
            
            // ABSOLUTE CHECK: If button is destroyed, no items allowed
            if (boss.itemButtonDestroyed) {
                console.log("🚫 BLOCKED: Item button is destroyed!");
                return t('itemDestroyed');
            }
            
            let message = "";
            
            // Enhanced logic for rage mode
            if (boss.enragedMode && boss.rageHealingBonus) {
                console.log("🔥 RAGE MODE ITEM HANDLING");
                
                // In rage mode, ONLY emergency heals work
                if (playerItems.emergencyHeal > 0) {
                    playerItems.emergencyHeal--;
                    boss.emergencyHealsUsed++;
                    player.hp = Math.min(player.maxHP, player.hp + 12);
                    message = t('healMessage', 12);
                    
                    console.log("🚨 Emergency heal used! Remaining:", playerItems.emergencyHeal);
                    
                    // Check if this was the last emergency heal
                    if (playerItems.emergencyHeal === 0) {
                        console.log("💥 LAST EMERGENCY HEAL USED - TRIGGERING DESTRUCTION!");
                        message += t('lastEmergencyHeal');
                        
                        // Trigger the item destruction cutscene immediately after this dialogue
                        setTimeout(() => {
                            if (!boss.itemButtonDestroyed) { // Double check
                                triggerItemDestructionCutscene();
                            }
                        }, 100); // Very short delay to let dialogue show first
                    }
                } else {
                    // NO ITEMS WORK IN RAGE MODE EXCEPT EMERGENCY HEALS
                    console.log("❌ No emergency heals left in rage mode!");
                    message = t('rageOnlyEmergency');
                }
            } else {
                // Normal item handling (not in rage mode)
                console.log("😊 NORMAL MODE ITEM HANDLING");
                
                if (playerItems.treats > 0) {
                    playerItems.treats--;
                    player.hp = Math.min(player.maxHP, player.hp + 8);
                    boss.mood = 'friendly';
                    message = t('treatOffer');
                } else if (playerItems.catnip > 0) {
                    playerItems.catnip--;
                    player.statusEffects.catnip = 120;
                    boss.mood = 'confused';
                    message = t('catnipScatter');
                } else {
                    message = t('noItems');
                }
            }
            
            console.log("📝 Item menu result:", message);
            return message;
        }

        function startEnding() {
            gameState = 'death_animation';
            boss.deathTimer = 0;
            
            // Force complete clearing
            forceCompleteClearing();
            clearGameVisuals();
            
            fadeOutMusic(2000);
            
            // Hide and disable menu
            menu.style.display = 'none';
            menu.style.pointerEvents = 'none';
            menuInstructions.style.display = 'none';
            attackInfo.style.display = 'none';
            attackTypeIndicator.style.display = 'none';
            rageModeIndicator.style.display = 'none';
            
            setTimeout(() => {
                gameState = 'ending';
                endingDialogueIndex = 0;
                showEndingDialogue();
                setTimeout(() => {
                    const currentVolume = volumeSlider.value;
                    volumeSlider.value = Math.max(20, currentVolume * 0.5);
                    fadeInMusic(3000);
                }, 1000);
            }, 3000);
        }

        function showEndingDialogue() {
            gameState = 'ending';
            dialogue.style.display = 'block';
            const dialogues = endingType === 'mercy' ? t('mercyEndingDialogues') : t('killEndingDialogues');
            dialogueText.textContent = dialogues[endingDialogueIndex];
        }

        function nextEndingDialogue() {
            endingDialogueIndex++;
            const dialogues = endingType === 'mercy' ? t('mercyEndingDialogues') : t('killEndingDialogues');
            
            if (endingDialogueIndex < dialogues.length) {
                dialogueText.textContent = dialogues[endingDialogueIndex];
            } else {
                dialogue.style.display = 'none';
                
                // Ensure menu is hidden and disabled
                menu.style.display = 'none';
                menu.style.pointerEvents = 'none';
                menuInstructions.style.display = 'none';
                
                endingOverlay.style.display = 'flex';
                
                if (endingType === 'mercy') {
                    victoryText.style.display = 'block';
                    victoryMessage.textContent = t('mercyVictory');
                    gameState = 'win';
                } else {
                    victoryText.style.display = 'block';
                    victoryMessage.textContent = t('killVictory');
                    gameState = 'win';
                }
                
                volumeSlider.value = Math.min(70, volumeSlider.value * 1.5);
                updateVolume();
            }
        }

        function handlePlayerDeath() {
            gameState = 'player_death';
            
            // Force complete clearing
            forceCompleteClearing();
            clearGameVisuals();
            
            playerDeathTimer = 0;
            
            // Hide and disable menu
            menu.style.display = 'none';
            menu.style.pointerEvents = 'none';
            menuInstructions.style.display = 'none';
            
            fadeOutMusic(2000);
            
            attackInfo.style.display = 'none';
            attackTypeIndicator.style.display = 'none';
            rageModeIndicator.style.display = 'none';
            
            setTimeout(() => {
                const deathDialogues = t('playerDeathDialogues');
                const deathDialogue = deathDialogues[Math.floor(Math.random() * deathDialogues.length)];
                showDialogue(deathDialogue);
                
                setTimeout(() => {
                    dialogue.style.display = 'none';
                    endingOverlay.style.display = 'flex';
                    gameoverText.style.display = 'block';
                    gameoverMessage.textContent = t('deathMessage');
                    gameState = 'gameover';
                }, 3000);
            }, 2000);
        }
        
        function startGame() {
            instructions.style.display = 'none';
            gameState = 'dialogue';
            attackInfo.style.display = 'block'; // Show attack info when game starts
            showDialogue(t('bossDialogues')[0]);
            startMusic();
        }
        
        function showDialogue(text) {
            gameState = 'dialogue';
            dialogue.style.display = 'block';
            menu.style.display = 'none';
            menuInstructions.style.display = 'none';
            dialogueText.textContent = text;
        }
        
        function nextDialogue() {
            if (gameState === 'win' || gameState === 'gameover' || gameState === 'ending' || gameState === 'player_death' || gameState === 'death_animation') return;
            
            dialogue.style.display = 'none';
            
            if (boss.hp <= 0 || gameState === 'win') {
                return;
            }
            
            gameState = 'attack';
            attackPhaseTimer = 0;
            startAttackPhase();
        }
        
        function startAttackPhase() {
            // Don't start attack phase if game has ended
            if (gameState === 'win' || gameState === 'gameover' || gameState === 'player_death' || gameState === 'death_animation') {
                return;
            }
            
            // Force complete clearing before starting new attack phase
            forceCompleteClearing();
            actionSelected = false;
            
            player.x = battleBox.x + battleBox.width / 2;
            player.y = battleBox.y + battleBox.height / 2;
            player.lastPosition = { x: player.x, y: player.y };
            
            // SET 1 SECOND INVINCIBILITY ON SPAWN
            player.invincibilityTimer = 60; // 60 frames = 1 second at 60fps
            
            boss.phase = Math.floor((boss.maxHP - boss.hp) / 50) + 1;
            currentPhaseSpan.textContent = boss.phase;
            
            attackTypeIndicator.style.display = 'block';
            
            // Attack phase lasts 5-8 seconds based on boss health
            const phaseDuration = boss.hp > 125 ? 5000 : (boss.hp > 75 ? 6500 : 8000);
            setTimeout(() => {
                endAttackPhase();
            }, phaseDuration);
        }
        
        function endAttackPhase() {
            // Don't show menu if game has ended
            if (gameState === 'win' || gameState === 'gameover' || gameState === 'player_death' || gameState === 'death_animation') {
                forceCompleteClearing();
                return;
            }
            
            // Force complete clearing when ending attack phase
            forceCompleteClearing();
            currentAttackSpan.textContent = t('preparing');
            attackTypeIndicator.style.display = 'none';
            
            gameState = 'menu';
            menu.style.display = 'block';
            menuInstructions.style.display = 'block';
            selectedMenuItem = 0;
            updateMenuSelection();
            turnCounter++;
        }
        
        function updateStats() {
            playerHPSpan.textContent = player.hp;
            bossHPSpan.textContent = boss.hp;
            
            let statusText = '';
            if (player.statusEffects.catnip > 0) {
                statusText += t('catnipHigh');
            }
            if (player.statusEffects.sleepy > 0) {
                statusText += t('sleepy');
            }
            if (boss.rageHealingBonus && playerItems.emergencyHeal > 0) {
                statusText += t('emergencyHeals') + playerItems.emergencyHeal + ' ';
            }
            statusEffect.textContent = statusText;
        }
        
        // Enhanced Attack patterns with MORE complexity and BETTER green patterns
        function generateRandomAttack() {
            // Don't generate attacks if game has ended or not in attack state
            if (gameState !== 'attack' || attacks.length > 50) { // Prevent overflow
                return;
            }
            
            // Increase attack frequency and complexity based on boss health and phase
            const healthPercent = boss.hp / boss.maxHP;
            const phase = boss.phase;
            
            let attackPool = [];
            let attackTypeUsed = 'white';
            
            // Enhanced attack pools with more variety
            const basicAttacks = ['yarnball', 'fishbone', 'pawswipe', 'laser'];
            const mediumAttacks = ['catnip', 'zoomies', 'mouse', 'string'];
            const advancedAttacks = ['treats', 'cardboard', 'scratching', 'hiding'];
            const expertAttacks = ['hairball', 'litter', 'blueBones', 'orangeZoomies'];
            const masterAttacks = ['determination', 'megalovania', 'enragedSwipe'];
            
            // Build attack pool based on phase
            attackPool.push(...basicAttacks);
            if (phase >= 2) attackPool.push(...mediumAttacks);
            if (phase >= 3) attackPool.push(...advancedAttacks);
            if (phase >= 4) attackPool.push(...expertAttacks);
            if (phase >= 5) attackPool.push(...masterAttacks);
            
            // Boss mood affects attack selection with more complexity
            if (boss.mood === 'friendly') {
                attackPool = ['healingTreats', 'spiralHealing', 'flowingHealing', 'healingWave'];
                attackTypeUsed = 'green';
            } else if (boss.mood === 'enraged' || boss.enragedMode) {
                if (musicPath === 'genocide') {
                    attackPool = ['megalovania', 'determination', 'enragedSwipe', 'comboAttack', 'blueBones', 'orangeZoomies'];
                    // Enhanced healing opportunities in rage mode with more variety
                    if (Math.random() < 0.12 && boss.rageHealingBonus) { // Increased from 0.075
                        const healingAttacks = ['mercyHealing', 'emergencyTreats', 'spiralHealing', 'healingBurst'];
                        attackPool.push(...healingAttacks);
                    }
                } else {
                    attackPool = ['enragedSwipe', 'comboAttack', 'blueBones', 'orangeZoomies', 'determination'];
                }
                attackTypeUsed = 'mixed';
            }
            
            // Enhanced combination attack chances
            if (phase >= 3 && Math.random() < 0.35) { // Increased from 0.3
                createEnhancedComboAttack();
                attackTypeUsed = 'mixed';
            } else {
                const attackType = attackPool[Math.floor(Math.random() * attackPool.length)];
                currentAttackType = attackType;
                currentAttackSpan.textContent = t('attackNames')[attackType] || attackType;
                
                // Enhanced attack type detection
                if (attackType.includes('blue') || attackType === 'blueBones') {
                    attackTypeUsed = 'blue';
                } else if (attackType.includes('orange') || attackType === 'orangeZoomies') {
                    attackTypeUsed = 'orange';
                } else if (attackType.includes('healing') || attackType.includes('Healing') || 
                          (attackType === 'treats' && boss.mood === 'friendly') || 
                          attackType === 'mercyHealing' || attackType === 'emergencyTreats') {
                    attackTypeUsed = 'green';
                }
                
                executeAttack(attackType);
            }
            
            // Update attack tip
            if (boss.rageHealingBonus && attackTypeUsed === 'green') {
                attackTip.textContent = t('attackTips')['healing'];
            } else {
                attackTip.textContent = t('attackTips')[attackTypeUsed] || t('attackTips')['white'];
            }
        }
        
        function executeAttack(attackType) {
            switch(attackType) {
                case 'yarnball': createYarnBallAttack(); break;
                case 'fishbone': createFishBoneAttack(); break;
                case 'pawswipe': createPawSwipeAttack(); break;
                case 'laser': createLaserPointerAttack(); break;
                case 'catnip': createCatnipCloudAttack(); break;
                case 'zoomies': createZoomiesAttack(); break;
                case 'mouse': createMouseToyAttack(); break;
                case 'treats': createTreatShowerAttack(); break;
                case 'cardboard': createCardboardBoxAttack(); break;
                case 'string': createStringAttack(); break;
                case 'hairball': createHairballAttack(); break;
                case 'nap': createNapAttack(); break;
                case 'scratching': createScratchingPostAttack(); break;
                case 'hiding': createHidingAttack(); break;
                case 'litter': createLitterBoxAttack(); break;
                case 'blueBones': createBlueBonesAttack(); break;
                case 'orangeZoomies': createOrangeZoomiesAttack(); break;
                case 'healingTreats': createHealingTreatsAttack(); break;
                case 'enragedSwipe': createEnragedSwipeAttack(); break;
                case 'megalovania': createMegalovaniaAttack(); break;
                case 'determination': createDeterminationAttack(); break;
                case 'mercyHealing': createMercyHealingAttack(); break;
                case 'emergencyTreats': createEmergencyTreatsAttack(); break;
                case 'spiralHealing': createSpiralHealingAttack(); break;
                case 'healingWave': createHealingWaveAttack(); break;
                case 'healingBurst': createHealingBurstAttack(); break;
                case 'flowingHealing': createFlowingHealingAttack(); break;
                default: createYarnBallAttack();
            }
        }
        
        function createEnhancedComboAttack() {
            currentAttackSpan.textContent = t('attackNames')['comboAttack'];
            
            // Enhanced combo with more variety - REDUCED DELAYS
            const comboPatterns = [
                // Pattern 1: Classic combo
                () => {
                    setTimeout(() => createYarnBallAttack(), 0);
                    setTimeout(() => createLaserPointerAttack(), 400); // Reduced from 600
                    setTimeout(() => createPawSwipeAttack(), 800); // Reduced from 1200
                    if (boss.phase >= 5) {
                        setTimeout(() => createBlueBonesAttack(), 1200); // Reduced from 1800
                    }
                },
                // Pattern 2: Healing focus
                () => {
                    setTimeout(() => createFishBoneAttack(), 0);
                    setTimeout(() => createSpiralHealingAttack(), 500); // Reduced from 800
                    setTimeout(() => createZoomiesAttack(), 1000); // Reduced from 1600
                },
                // Pattern 3: Complex mix
                () => {
                    setTimeout(() => createStringAttack(), 0);
                    setTimeout(() => createOrangeZoomiesAttack(), 300); // Reduced from 500
                    setTimeout(() => createHealingWaveAttack(), 600); // Reduced from 1000
                    setTimeout(() => createMouseToyAttack(), 900); // Reduced from 1500
                }
            ];
            
            const pattern = comboPatterns[Math.floor(Math.random() * comboPatterns.length)];
            pattern();
            
            // Add healing opportunity in combo attacks during rage mode - enhanced
            if (boss.rageHealingBonus && Math.random() < 0.4) { // Increased from 0.3
                setTimeout(() => createMercyHealingAttack(), 1500); // Reduced from 2200
            }
        }

        // NEW DYNAMIC GREEN HEALING ATTACKS
        function createSpiralHealingAttack() {
            // Creates a dynamic spiral of healing particles - REDUCED DELAYS
            currentAttackSpan.textContent = t('attackNames')['spiralHealing'];
            
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const angle = (i / 8) * Math.PI * 2;
                    const radius = 80 + i * 15;
                    const centerX = battleBox.x + battleBox.width / 2;
                    const centerY = battleBox.y + battleBox.height / 2;
                    
                    attacks.push({
                        type: 'spiralHealing',
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius,
                        dx: -Math.cos(angle) * 2,
                        dy: -Math.sin(angle) * 2,
                        size: 12,
                        color: '#00ff88',
                        attackColor: 'green',
                        healAmount: 4,
                        trail: [],
                        spiralSpeed: 0.08
                    });
                }, i * 100); // Reduced from 150
            }
        }

        function createHealingWaveAttack() {
            // Creates waves of healing that flow across the screen - REDUCED DELAYS
            currentAttackSpan.textContent = t('attackNames')['healingWave'];
            
            for (let wave = 0; wave < 3; wave++) {
                setTimeout(() => {
                    for (let i = 0; i < 6; i++) {
                        attacks.push({
                            type: 'healingWave',
                            x: battleBox.x - 20,
                            y: battleBox.y + i * (battleBox.height / 5),
                            dx: 3 + wave * 0.5,
                            dy: Math.sin(i + wave) * 1.5,
                            size: 10,
                            color: '#44ff44',
                            attackColor: 'green',
                            healAmount: 3,
                            waveOffset: i + wave * 3
                        });
                    }
                }, wave * 500); // Reduced from 800
            }
        }

        function createHealingBurstAttack() {
            // Creates bursts of healing that expand outward
            currentAttackSpan.textContent = t('attackNames')['healingBurst'];
            
            const burstCenters = [
                { x: battleBox.x + battleBox.width * 0.3, y: battleBox.y + battleBox.height * 0.3 },
                { x: battleBox.x + battleBox.width * 0.7, y: battleBox.y + battleBox.height * 0.7 }
            ];
            
            burstCenters.forEach((center, burstIndex) => {
                setTimeout(() => {
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        attacks.push({
                            type: 'healingBurst',
                            x: center.x,
                            y: center.y,
                            dx: Math.cos(angle) * 2.5,
                            dy: Math.sin(angle) * 2.5,
                            size: 8,
                            color: '#66ff66',
                            attackColor: 'green',
                            healAmount: 2,
                            expandTimer: 0
                        });
                    }
                }, burstIndex * 600);
            });
        }

        function createFlowingHealingAttack() {
            // Creates flowing healing particles that follow curved paths
            currentAttackSpan.textContent = t('attackNames')['flowingHealing'];
            
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    attacks.push({
                        type: 'flowingHealing',
                        x: battleBox.x + Math.random() * battleBox.width,
                        y: battleBox.y - 20,
                        dx: (Math.random() - 0.5) * 2,
                        dy: 1.5,
                        size: 12,
                        color: '#88ff88',
                        attackColor: 'green',
                        healAmount: 4,
                        flowPhase: Math.random() * Math.PI * 2,
                        trail: []
                    });
                }, i * 300);
            }
        }

        // Enhanced original healing attacks for rage mode
        function createMercyHealingAttack() {
            // Enhanced: Creates a more dynamic wave of healing particles
            for (let i = 0; i < 4; i++) { // Increased from 3
                attacks.push({
                    type: 'mercyHealing',
                    x: battleBox.x + (i + 0.5) * (battleBox.width / 4),
                    y: battleBox.y - 10,
                    dx: (Math.random() - 0.5) * 1,
                    dy: 1.5 + Math.random(),
                    size: 10,
                    color: '#22ff22',
                    attackColor: 'green',
                    healAmount: 3
                });
            }
        }

        function createEmergencyTreatsAttack() {
            // Enhanced: Creates more healing opportunities with movement
            for (let i = 0; i < 3; i++) { // Increased from 2
                const x = battleBox.x + (i + 0.5) * (battleBox.width / 3);
                attacks.push({
                    type: 'emergencyTreats',
                    x: x,
                    y: battleBox.y - 10,
                    dx: (Math.random() - 0.5) * 1.5,
                    dy: 1.8,
                    size: 15,
                    color: '#00ff44',
                    attackColor: 'green',
                    healAmount: 5,
                    timer: 200, // Increased lifetime
                    pulse: 0
                });
            }
        }

        // New special attacks for rage mode
        function createMegalovaniaAttack() {
            // Enhanced special attack pattern - MORE COMPLEX
            const patterns = [
                // Bone wall from bottom - ENHANCED
                () => {
                    for (let i = 0; i < 10; i++) { // Increased from 8
                        attacks.push({
                            type: 'megalovania',
                            x: battleBox.x + 10 + i * 48,
                            y: battleBox.y + battleBox.height,
                            dx: 0,
                            dy: -6 - Math.random() * 2, // Variable speed
                            size: 15,
                            color: '#87ceeb',
                            attackColor: 'blue',
                            height: 60 + Math.random() * 20 // Variable height
                        });
                    }
                },
                // Circling bones - ENHANCED with variable patterns
                () => {
                    for (let i = 0; i < 15; i++) { // Increased from 12
                        const angle = (i / 15) * Math.PI * 2;
                        const radius = 130 + Math.sin(i) * 30; // Variable radius
                        attacks.push({
                            type: 'megalovania',
                            x: battleBox.x + battleBox.width/2 + Math.cos(angle) * radius,
                            y: battleBox.y + battleBox.height/2 + Math.sin(angle) * radius,
                            targetX: battleBox.x + battleBox.width/2,
                            targetY: battleBox.y + battleBox.height/2,
                            size: 12,
                            color: '#ffa500',
                            attackColor: 'orange',
                            speed: 2.5 + Math.random() * 1.5 // Variable speed
                        });
                    }
                },
                // NEW: Cross pattern
                () => {
                    for (let i = 0; i < 8; i++) {
                        // Horizontal line
                        attacks.push({
                            type: 'megalovania',
                            x: battleBox.x + i * 60,
                            y: battleBox.y + battleBox.height/2,
                            dx: 0,
                            dy: i % 2 === 0 ? -4 : 4,
                            size: 14,
                            color: '#ff6b6b',
                            attackColor: 'white'
                        });
                        // Vertical line
                        attacks.push({
                            type: 'megalovania',
                            x: battleBox.x + battleBox.width/2,
                            y: battleBox.y + i * 25,
                            dx: i % 2 === 0 ? -4 : 4,
                            dy: 0,
                            size: 14,
                            color: '#6b6bff',
                            attackColor: 'white'
                        });
                    }
                }
            ];
            
            // Enhanced pattern cycling with more variety
            attackPatternCounters.megalovania = (attackPatternCounters.megalovania || 0) % patterns.length;
            patterns[attackPatternCounters.megalovania]();
            attackPatternCounters.megalovania++;
        }

        function createDeterminationAttack() {
            // Enhanced: More complex patterns with variable timing - REDUCED DELAYS
            const intensity = 1 + (1 - boss.hp / boss.maxHP) * 2.5; // Increased multiplier
            
            for (let i = 0; i < 6 * intensity; i++) { // Increased base count
                setTimeout(() => {
                    const pattern = i % 3;
                    let startX, startY, dx, dy;
                    
                    switch(pattern) {
                        case 0: // From left
                            startX = battleBox.x - 20;
                            startY = battleBox.y + 20 + (i % 8) * 20;
                            dx = 7 + Math.random() * 2;
                            dy = (Math.random() - 0.5) * 1;
                            break;
                        case 1: // From right
                            startX = battleBox.x + battleBox.width + 20;
                            startY = battleBox.y + 20 + (i % 8) * 20;
                            dx = -(7 + Math.random() * 2);
                            dy = (Math.random() - 0.5) * 1;
                            break;
                        case 2: // From top
                            startX = battleBox.x + 20 + (i % 10) * 46;
                            startY = battleBox.y - 20;
                            dx = (Math.random() - 0.5) * 1;
                            dy = 6 + Math.random() * 2;
                            break;
                    }
                    
                    attacks.push({
                        type: 'determination',
                        x: startX,
                        y: startY,
                        dx: dx,
                        dy: dy,
                        size: 8,
                        color: '#ff0000',
                        attackColor: 'white',
                        trail: []
                    });
                }, i * 120); // Reduced from 180
            }
        }
        
        // ENHANCED FIXED PATTERN ATTACK FUNCTIONS
        
        function createBlueBonesAttack() {
            // Enhanced: Blue attacks with more variety
            const count = boss.phase >= 3 ? 8 : 6; // Increased
            const spacing = battleBox.width / (count + 1);
            
            for (let i = 0; i < count; i++) {
                attacks.push({
                    type: 'blueBones',
                    x: battleBox.x + spacing * (i + 1),
                    y: battleBox.y - 20,
                    dx: Math.sin(i) * 0.5, // Slight horizontal movement
                    dy: 3 + Math.random() * 1, // Variable speed
                    size: 15,
                    color: '#87ceeb',
                    attackColor: 'blue'
                });
            }
        }
        
        function createOrangeZoomiesAttack() {
            // Enhanced: Orange attacks with more complex patterns
            const count = boss.phase >= 3 ? 10 : 8; // Increased
            const angleStep = (Math.PI * 2) / count;
            
            for (let i = 0; i < count; i++) {
                const angle = i * angleStep;
                const speed = 3.5 + Math.random() * 1.5; // Variable speed
                attacks.push({
                    type: 'orangeZoomies',
                    x: battleBox.x + battleBox.width/2,
                    y: battleBox.y + battleBox.height/2,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    size: 12,
                    color: '#ffa500',
                    attackColor: 'orange',
                    trail: []
                });
            }
        }
        
        function createHealingTreatsAttack() {
            // Enhanced: More dynamic healing positions
            const count = boss.rageHealingBonus ? 4 : 3; // Increased
            
            for (let i = 0; i < count; i++) {
                const x = battleBox.x + Math.random() * battleBox.width;
                attacks.push({
                    type: 'healingTreats',
                    x: x,
                    y: battleBox.y - 10,
                    dx: (Math.random() - 0.5) * 1, // Slight horizontal movement
                    dy: 1.5 + Math.random() * 0.5,
                    size: 8,
                    color: '#00ff00',
                    attackColor: 'green',
                    healAmount: boss.rageHealingBonus ? 3 : 2
                });
            }
        }
        
        function createEnragedSwipeAttack() {
            // Enhanced: More complex swipe patterns - REDUCED DELAYS
            const positions = [
                { x: battleBox.x + battleBox.width * 0.2, y: battleBox.y + battleBox.height * 0.2 },
                { x: battleBox.x + battleBox.width * 0.8, y: battleBox.y + battleBox.height * 0.8 },
                { x: battleBox.x + battleBox.width * 0.5, y: battleBox.y + battleBox.height * 0.5 },
                { x: battleBox.x + battleBox.width * 0.8, y: battleBox.y + battleBox.height * 0.2 },
                { x: battleBox.x + battleBox.width * 0.2, y: battleBox.y + battleBox.height * 0.8 }
            ];
            
            const count = Math.min(boss.phase, 4); // More swipes at higher phases
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    const pos = positions[i];
                    
                    particles.push({
                        type: 'warning',
                        x: pos.x,
                        y: pos.y,
                        timer: 35, // Reduced from 45
                        size: 55,
                        color: '#ff0000'
                    });
                    
                    setTimeout(() => {
                        attacks.push({
                            type: 'enragedSwipe',
                            x: pos.x - 40,
                            y: pos.y - 40,
                            size: 80, // Larger swipes
                            timer: 35,
                            color: '#ff4500'
                        });
                    }, 580); // Reduced from 750
                }, i * 300); // Reduced from 400
            }
        }
        
        // Enhanced original attack functions with MORE complexity
        function createYarnBallAttack() {
            const count = boss.phase >= 3 ? 8 : 6; // Increased
            const spacing = battleBox.width / count;
            
            // Enhanced pattern counter for more variety
            attackPatternCounters.yarnball = (attackPatternCounters.yarnball + 1) % 3; // Increased patterns
            const pattern = attackPatternCounters.yarnball;
            
            for (let i = 0; i < count; i++) {
                let dx, dy;
                switch(pattern) {
                    case 0: // Left-right bounce
                        dx = 1 + i * 0.3;
                        dy = 2;
                        break;
                    case 1: // Right-left bounce
                        dx = -(1 + i * 0.3);
                        dy = 2;
                        break;
                    case 2: // Zigzag pattern
                        dx = (i % 2 === 0 ? 1 : -1) * (1.5 + i * 0.2);
                        dy = 2.5;
                        break;
                }
                
                attacks.push({
                    type: 'yarnball',
                    x: battleBox.x + spacing * i + spacing / 2,
                    y: battleBox.y - 20,
                    dx: dx,
                    dy: dy,
                    size: 12,
                    color: '#ff69b4',
                    bounces: boss.phase >= 4 ? 4 : 3, // More bounces
                    attackColor: 'white'
                });
            }
        }
        
        function createFishBoneAttack() {
            // Enhanced: More complex side patterns
            attackPatternCounters.fishbone = (attackPatternCounters.fishbone + 1) % 3; // More patterns
            const pattern = attackPatternCounters.fishbone;
            const count = boss.phase >= 3 ? 10 : 8; // Increased
            
            let startX, dx, spacing;
            switch(pattern) {
                case 0: // From left
                    startX = battleBox.x - 20;
                    dx = 5 + boss.phase;
                    spacing = battleBox.height / count;
                    break;
                case 1: // From right
                    startX = battleBox.x + battleBox.width + 20;
                    dx = -(5 + boss.phase);
                    spacing = battleBox.height / count;
                    break;
                case 2: // Both sides alternating
                    for (let i = 0; i < count; i++) {
                        const side = i % 2;
                        attacks.push({
                            type: 'fishbone',
                            x: side === 0 ? battleBox.x - 20 : battleBox.x + battleBox.width + 20,
                            y: battleBox.y + (i * battleBox.height / count),
                            dx: side === 0 ? (5 + boss.phase) : -(5 + boss.phase),
                            dy: (Math.random() - 0.5) * 1, // Slight vertical movement
                            size: 10,
                            color: '#ffd700',
                            attackColor: 'white'
                        });
                    }
                    return; // Early return for pattern 2
            }
            
            for (let i = 0; i < count; i++) {
                attacks.push({
                    type: 'fishbone',
                    x: startX,
                    y: battleBox.y + spacing * i,
                    dx: dx,
                    dy: (Math.random() - 0.5) * 0.5, // Slight vertical variance
                    size: 10,
                    color: '#ffd700',
                    attackColor: 'white'
                });
            }
        }
        
        function createPawSwipeAttack() {
            // Enhanced: Multiple target positions with better warning - REDUCED DELAY
            const targetCount = boss.phase >= 4 ? 2 : 1;
            
            for (let i = 0; i < targetCount; i++) {
                setTimeout(() => {
                    const targetX = player.x + (Math.random() - 0.5) * 60; // Less precise targeting
                    const targetY = player.y + (Math.random() - 0.5) * 60;
                    
                    particles.push({
                        type: 'warning',
                        x: targetX,
                        y: targetY,
                        timer: 60, // Reduced from 90
                        size: 45,
                        color: '#ff0000'
                    });
                    
                    setTimeout(() => {
                        attacks.push({
                            type: 'pawswipe',
                            x: targetX - 35,
                            y: targetY - 35,
                            size: 70,
                            timer: 45,
                            color: '#8b4513',
                            attackColor: 'white'
                        });
                    }, 1000); // Reduced from 1500
                }, i * 600); // Reduced from 800
            }
        }
        
        function createLaserPointerAttack() {
            // Enhanced: Multiple lasers with different speeds - REDUCED DELAYS
            const laserCount = boss.phase >= 3 ? 3 : 2;
            
            for (let i = 0; i < laserCount; i++) {
                setTimeout(() => {
                    const angle = Math.atan2(player.y - (battleBox.y + battleBox.height/2), 
                                           player.x - (battleBox.x + battleBox.width/2)) + (Math.random() - 0.5) * 0.5;
                    
                    attacks.push({
                        type: 'laser',
                        x: battleBox.x + battleBox.width/2,
                        y: battleBox.y + battleBox.height/2,
                        dx: Math.cos(angle) * (4 + boss.phase + i),
                        dy: Math.sin(angle) * (4 + boss.phase + i),
                        size: 8,
                        color: ['#ff0000', '#ff4500', '#ff6600'][i] || '#ff0000',
                        trail: [],
                        attackColor: 'white'
                    });
                }, i * 250); // Reduced from 400
            }
        }
        
        function createCatnipCloudAttack() {
            // Enhanced: More dynamic grid with movement
            const rows = 5;
            const cols = 6;
            const spacingX = battleBox.width / (cols + 1);
            const spacingY = battleBox.height / (rows + 1);
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    attacks.push({
                        type: 'catnip',
                        x: battleBox.x + spacingX * (col + 1),
                        y: battleBox.y + spacingY * (row + 1),
                        dx: (Math.random() - 0.5) * 0.5, // Slight movement
                        dy: (Math.random() - 0.5) * 0.5,
                        size: 6,
                        color: '#90EE90',
                        timer: 200, // Longer lifetime
                        attackColor: 'white'
                    });
                }
            }
        }
        
        function createZoomiesAttack() {
            // Enhanced: More complex radial patterns
            const count = boss.phase >= 3 ? 12 : 10;
            const angleStep = (Math.PI * 2) / count;
            const speed = 5 + boss.phase * 0.5;
            
            for (let i = 0; i < count; i++) {
                const angle = i * angleStep;
                attacks.push({
                    type: 'zoomies',
                    x: battleBox.x + battleBox.width/2,
                    y: battleBox.y + battleBox.height/2,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    size: 15,
                    color: '#FFB6C1',
                    trail: [],
                    attackColor: 'white',
                    spiralFactor: 0.02 // Add spiral movement
                });
            }
        }
        
        function createMouseToyAttack() {
            // Enhanced: More complex targeting with prediction
            const fixedPositions = [
                { x: battleBox.x + 50, y: battleBox.y + 50 },
                { x: battleBox.x + battleBox.width - 50, y: battleBox.y + 50 },
                { x: battleBox.x + 50, y: battleBox.y + battleBox.height - 50 },
                { x: battleBox.x + battleBox.width - 50, y: battleBox.y + battleBox.height - 50 },
                { x: battleBox.x + battleBox.width/2, y: battleBox.y + 30 }
            ];
            
            const count = boss.phase >= 4 ? 5 : 4;
            for (let i = 0; i < count; i++) {
                const startPos = fixedPositions[i % fixedPositions.length];
                // Predict player movement slightly
                const predictedX = player.x + (keys['arrowright'] || keys['d'] ? 30 : 0) - (keys['arrowleft'] || keys['a'] ? 30 : 0);
                const predictedY = player.y + (keys['arrowdown'] || keys['s'] ? 30 : 0) - (keys['arrowup'] || keys['w'] ? 30 : 0);
                
                attacks.push({
                    type: 'mouse',
                    x: startPos.x,
                    y: startPos.y,
                    targetX: predictedX,
                    targetY: predictedY,
                    size: 8,   
                    color: '#8B4513',
                    speed: 2.5 + boss.phase * 0.3,
                    attackColor: 'white'
                });
            }
        }
        
        function createTreatShowerAttack() {
            // Enhanced: More dynamic shower patterns - REDUCED DELAYS
            const count = boss.phase >= 3 ? 18 : 15;
            const healingTreats = boss.mood === 'friendly' || (boss.rageHealingBonus && Math.random() < 0.15);
            
            for (let i = 0; i < count; i++) {
                const x = battleBox.x + Math.random() * battleBox.width;
                const delay = Math.random() * 600; // Reduced from 1000
                
                setTimeout(() => {
                    attacks.push({
                        type: healingTreats ? 'healingTreats' : 'treats',
                        x: x,
                        y: battleBox.y - 20 - Math.random() * 50,
                        dx: (Math.random() - 0.5) * 1,
                        dy: 1.5 + Math.random() * 1.5,
                        size: 5,
                        color: healingTreats ? '#00ff00' : '#D2691E',
                        attackColor: healingTreats ? 'green' : 'white',
                        healAmount: healingTreats ? (boss.rageHealingBonus ? 3 : 2) : 0
                    });
                }, delay);
            }
        }
        
        function createCardboardBoxAttack() {
            // Enhanced: Multiple boxes with different timings
            const boxCount = boss.phase >= 4 ? 2 : 1;
            const positions = [
                { x: battleBox.x + battleBox.width/2 - 30, y: battleBox.y + battleBox.height/2 - 30 },
                { x: battleBox.x + battleBox.width/4 - 20, y: battleBox.y + battleBox.height/4 - 20 }
            ];
            
            for (let i = 0; i < boxCount; i++) {
                const pos = positions[i];
                attacks.push({
                    type: 'cardboard',
                    x: pos.x,
                    y: pos.y,
                    size: 60,
                    color: '#DEB887',
                    timer: 150 + boss.phase * 15,
                    phase: 0,
                    attackColor: 'white'
                });
            }
        }
        
        function createStringAttack() {
            // Enhanced: More complex wave patterns
            const startX = battleBox.x;
            const startY = battleBox.y + battleBox.height/2;
            const count = boss.phase >= 4 ? 15 : 12;
            const waveVariations = 3;
            
            for (let i = 0; i < count; i++) {
                const waveType = i % waveVariations;
                let dy;
                switch(waveType) {
                    case 0: dy = Math.sin(i * 0.5) * 2; break;
                    case 1: dy = Math.cos(i * 0.3) * 2.5; break;
                    case 2: dy = Math.sin(i * 0.8) * 1.5; break;
                }
                
                attacks.push({
                    type: 'string',
                    x: startX - i * 18,
                    y: startY,
                    dx: 2.5 + boss.phase * 0.3,
                    dy: dy,
                    size: 4,
                    color: '#FF1493',
                    waveOffset: i * 0.5,
                    attackColor: 'white'
                });
            }
        }
        
        function createHairballAttack() {
            // Enhanced: Multiple hairballs with better targeting - REDUCED DELAY
            const hairballCount = boss.phase >= 4 ? 3 : 2;
            const positions = [
                { x: battleBox.x + battleBox.width/2, y: battleBox.y + 50 },
                { x: battleBox.x + battleBox.width/4, y: battleBox.y + 40 },
                { x: battleBox.x + 3*battleBox.width/4, y: battleBox.y + 60 }
            ];
            
            for (let i = 0; i < hairballCount; i++) {
                const pos = positions[i];
                particles.push({
                    type: 'warning',
                    x: pos.x,
                    y: pos.y,
                    timer: 50, // Reduced from 70
                    size: 55,
                    color: '#ff0000'
                });
                
                setTimeout(() => {
                    attacks.push({
                        type: 'hairball',
                        x: pos.x,
                        y: battleBox.y,
                        dx: (Math.random() - 0.5) * 1,
                        dy: 3.5 + boss.phase,
                        size: 25,
                        color: '#8B4513',
                        attackColor: 'white'
                    });
                }, 800); // Reduced from 1200
            }
        }
        
        function createNapAttack() {
            player.statusEffects.sleepy = 150; // Longer effect
            currentAttackSpan.textContent = t('attackNames')['nap'] + t('feelSleepy');
        }
        
        function createScratchingPostAttack() {
            // Enhanced: More complex vertical patterns
            const count = boss.phase >= 4 ? 8 : 6;
            const spacing = battleBox.width / (count + 1);
            
            for (let i = 0; i < count; i++) {
                attacks.push({
                    type: 'scratching',
                    x: battleBox.x + spacing * (i + 1),
                    y: battleBox.y,
                    dx: (Math.random() - 0.5) * 0.5, // Slight horizontal drift
                    dy: 4.5 + boss.phase,
                    size: 8,
                    color: '#8B4513',
                    length: battleBox.height,
                    attackColor: 'white'
                });
            }
        }
        
        function createHidingAttack() {
            // Enhanced: More hiding spots with different sizes
            const fixedShadows = [
                { x: battleBox.x + 40, y: battleBox.y + battleBox.height - 35, size: 90 },
                { x: battleBox.x + battleBox.width - 140, y: battleBox.y + battleBox.height - 45, size: 100 },
                { x: battleBox.x + battleBox.width/2 - 35, y: battleBox.y + 40, size: 70 },
                { x: battleBox.x + battleBox.width/4, y: battleBox.y + battleBox.height/2, size: 80 }
            ];
            
            const count = boss.phase >= 4 ? 4 : 3;
            for (let i = 0; i < count; i++) {
                const pos = fixedShadows[i];
                attacks.push({
                    type: 'hiding',
                    x: pos.x,
                    y: pos.y,
                    size: pos.size,
                    color: '#333333',
                    timer: 180 + boss.phase * 15,
                    phase: 0,
                    attackColor: 'white'
                });
            }
        }
        
        function createLitterBoxAttack() {
            // Enhanced: More litter boxes with staggered appearance - REDUCED DELAYS
            const corners = [
                {x: battleBox.x, y: battleBox.y},
                {x: battleBox.x + battleBox.width - 45, y: battleBox.y},
                {x: battleBox.x, y: battleBox.y + battleBox.height - 45},
                {x: battleBox.x + battleBox.width - 45, y: battleBox.y + battleBox.height - 45},
                {x: battleBox.x + battleBox.width/2 - 20, y: battleBox.y + battleBox.height/2 - 20}
            ];
            
            const count = boss.phase >= 5 ? 5 : 4;
            corners.slice(0, count).forEach((corner, index) => {
                setTimeout(() => {
                    attacks.push({
                        type: 'litter',
                        x: corner.x,
                        y: corner.y,
                        size: 40,
                        color: '#D2B48C',
                        timer: 250,
                        attackColor: 'white'
                    });
                }, index * 150); // Reduced from 300
            });
        }
        
        // Simplified game loop without complex delta time but with better clearing
        function gameLoop() {
            frameCount++;
            
            // Force clear canvas every frame to prevent leftovers
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (gameState === 'attack') {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.strokeRect(battleBox.x, battleBox.y, battleBox.width, battleBox.height);
            }
            
            drawCatBoss();
            
            if (gameState === 'attack') {
                updateStatusEffects();
                updatePlayer();
                
                // Update invincibility timer
                if (player.invincibilityTimer > 0) {
                    player.invincibilityTimer--;
                }
                
                attackPhaseTimer++;
                attackTimer++;
                
                // Generate attacks based on boss phase and health - Slower timing
                const baseFrequency = Math.max(45, 140 - boss.phase * 10 - (boss.enragedMode ? 20 : 0));
                const variableFrequency = baseFrequency + Math.sin(frameCount * 0.08) * 15; // Add some variance
                
                if (frameCount % Math.floor(variableFrequency) === 0) {
                    generateRandomAttack();
                }
                
                updateAttacks();
                updateParticles();
                drawPlayer();
                checkCollisions();
                
                // Check for player death immediately
                if (player.hp <= 0 && gameState === 'attack') {
                    handlePlayerDeath();
                    return;
                }
            }
            else if (gameState === 'menu' || gameState === 'dialogue' || gameState === 'cutscene' || gameState === 'item_destruction_cutscene') {
                // Still draw player during menu/dialogue states
                drawPlayer();
                updateParticles();
            }

            if (gameState === 'death_animation') {
                updateDeathAnimation();
            }

            if (gameState === 'player_death') {
                updatePlayerDeathAnimation();
            }
            
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function updatePlayerDeathAnimation() {
            playerDeathTimer++;
            
            // Create death effects around player - reduced frequency
            if (frameCount % 15 === 0) {
                particles.push({
                    type: 'playerDeath',
                    x: player.x + (Math.random() - 0.5) * 40,
                    y: player.y + (Math.random() - 0.5) * 40,
                    timer: 60,
                    color: `hsl(${Math.random() * 60}, 100%, 50%)`
                });
            }
            
            // Update death particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                if (particle.type === 'playerDeath') {
                    particle.timer--;
                    particle.y -= 2;
                    
                    if (particle.timer <= 0) {
                        particles.splice(i, 1);
                        continue;
                    }
                    
                    ctx.fillStyle = particle.color;
                    ctx.globalAlpha = particle.timer / 60;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }
            
            // Draw fading player heart
            const alpha = Math.max(0, 1 - playerDeathTimer / 120);
            ctx.globalAlpha = alpha;
            drawPlayer();
            ctx.globalAlpha = 1;
        }

        function updateDeathAnimation() {
            boss.deathTimer++;
            
            boss.opacity = Math.max(0, 1 - boss.deathTimer / 180);
            boss.scale = Math.max(0.3, 1 - boss.deathTimer / 300);
            
            if (frameCount % 10 === 0) {
                boss.deathEffects.push({
                    x: canvas.width / 2 + (Math.random() - 0.5) * 100,
                    y: 100 + (Math.random() - 0.5) * 100,
                    timer: 60,
                    color: `hsl(${Math.random() * 360}, 100%, 70%)`
                });
            }
            
            for (let i = boss.deathEffects.length - 1; i >= 0; i--) {
                const effect = boss.deathEffects[i];
                effect.timer--;
                effect.y -= 2;
                
                if (effect.timer <= 0) {
                    boss.deathEffects.splice(i, 1);
                    continue;
                }
                
                ctx.fillStyle = effect.color;
                ctx.globalAlpha = effect.timer / 60;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        
        function updateStatusEffects() {
            if (player.statusEffects.catnip > 0) {
                player.statusEffects.catnip--;
            }
            
            if (player.statusEffects.sleepy > 0) {
                player.statusEffects.sleepy--;
            }
            
            updateStats();
        }
        
        function drawCatBoss() {
            const centerX = canvas.width / 2;
            const centerY = 100;
            const bodyOffset = Math.sin(frameCount * 0.05) * 2;
            
            ctx.globalAlpha = boss.opacity;
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(boss.scale, boss.scale);
            ctx.translate(-centerX, -centerY);
            
            // Cat body - color changes based on mood and health
            let bodyColor = '#888';
            if (boss.mood === 'friendly') bodyColor = '#AAA';
            if (boss.mood === 'enraged' || boss.enragedMode) {
                if (musicPath === 'genocide') {
                    bodyColor = '#444'; // Darker for genocide route
                } else {
                    bodyColor = '#666';
                }
            }
            if (boss.hp <= 50) bodyColor = '#555';
            
            ctx.fillStyle = bodyColor;
            ctx.fillRect(centerX - 40, centerY + bodyOffset, 80, 60);
            
            // Cat head
            ctx.fillStyle = bodyColor;
            ctx.fillRect(centerX - 30, centerY - 40 + bodyOffset, 60, 40);
            
            // Cat ears
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.moveTo(centerX - 25, centerY - 40 + bodyOffset);
            ctx.lineTo(centerX - 15, centerY - 55 + bodyOffset);
            ctx.lineTo(centerX - 5, centerY - 40 + bodyOffset);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(centerX + 5, centerY - 40 + bodyOffset);
            ctx.lineTo(centerX + 15, centerY - 55 + bodyOffset);
            ctx.lineTo(centerX + 25, centerY - 40 + bodyOffset);
            ctx.fill();
            
            // Cat eyes - change based on mood and health
            let eyeColor = '#00ff00';
            if (boss.mood === 'enraged' || boss.enragedMode) {
                if (musicPath === 'genocide') {
                    eyeColor = '#ff0000'; // Red eyes for genocide route
                } else {
                    eyeColor = '#ff4500';
                }
            }
            if (boss.mood === 'friendly') eyeColor = '#00ff00';
            if (boss.hp <= 50) eyeColor = '#ffff00';
            
            ctx.fillStyle = eyeColor;
            ctx.fillRect(centerX - 20, centerY - 30 + bodyOffset, 8, 8);
            ctx.fillRect(centerX + 12, centerY - 30 + bodyOffset, 8, 8);
            
            // Cat pupils
            ctx.fillStyle = '#000';
            const pupilWidth = boss.mood === 'confused' ? 1 : (boss.enragedMode ? 3 : 2);
            ctx.fillRect(centerX - 19, centerY - 28 + bodyOffset, pupilWidth, 4);
            ctx.fillRect(centerX + 13, centerY - 28 + bodyOffset, pupilWidth, 4);
            
            // Cat tail
            ctx.fillStyle = bodyColor;
            const tailSway = Math.sin(frameCount * (boss.enragedMode ? 0.3 : 0.15)) * (boss.enragedMode ? 25 : 15);
            const tailHeight = Math.sin(frameCount * 0.08) * 5;
            ctx.fillRect(centerX + 40, centerY + 20 + bodyOffset + tailHeight, 30 + tailSway, 8);
            
            // Mood indicators
            if (boss.mood === 'friendly') {
                ctx.fillStyle = '#ff69b4';
                ctx.font = '16px Arial';
                ctx.fillText('♥', centerX - 60, centerY - 10);
                ctx.fillText('♥', centerX + 50, centerY - 5);
            } else if (boss.mood === 'enraged' || boss.enragedMode) {
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX - 50, centerY - 20);
                ctx.lineTo(centerX - 40, centerY - 30);
                ctx.moveTo(centerX - 50, centerY - 30);
                ctx.lineTo(centerX - 40, centerY - 20);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(centerX + 40, centerY - 20);
                ctx.lineTo(centerX + 50, centerY - 30);
                ctx.moveTo(centerX + 40, centerY - 30);
                ctx.lineTo(centerX + 50, centerY - 20);
                ctx.stroke();

                // Extra effects for genocide route
                if (musicPath === 'genocide' && boss.musicTriggered) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5;
                    ctx.strokeRect(centerX - 60, centerY - 60, 120, 120);
                    ctx.globalAlpha = boss.opacity;
                }
            }
            
            ctx.restore();
            ctx.globalAlpha = 1;
        }
        
        function updatePlayer() {
            // Don't update player during end states
            if (gameState === 'win' || gameState === 'gameover' || gameState === 'player_death' || gameState === 'death_animation') {
                return;
            }
            
            // Track if player is moving for blue/orange attacks
            player.isMoving = (player.x !== player.lastPosition.x || player.y !== player.lastPosition.y);
            player.lastPosition = { x: player.x, y: player.y };
            
            let speed = 3;
            
            if (player.statusEffects.catnip > 0) {
                speed = 1.5;
            }
            if (player.statusEffects.sleepy > 0) {
                speed = 2;
            }
            
            let moveX = 0, moveY = 0;
            
            if (keys['arrowleft'] || keys['a']) moveX = -1;
            if (keys['arrowright'] || keys['d']) moveX = 1;
            if (keys['arrowup'] || keys['w']) moveY = -1;
            if (keys['arrowdown'] || keys['s']) moveY = 1;
            
            if (player.statusEffects.catnip > 0 && Math.random() < 0.3) {
                moveX *= -1;
                moveY *= -1;
            }
            
            const newX = player.x + moveX * speed;
            const newY = player.y + moveY * speed;
            
            if (newX >= battleBox.x + player.size && newX <= battleBox.x + battleBox.width - player.size) {
                player.x = newX;
            }
            if (newY >= battleBox.y + player.size && newY <= battleBox.y + battleBox.height - player.size) {
                player.y = newY;
            }
        }
        
        function drawPlayer() {
            let heartColor = '#ff0000';
            if (player.statusEffects.catnip > 0) {
                heartColor = `hsl(${frameCount % 360}, 100%, 50%)`;
            }
            if (player.statusEffects.sleepy > 0) {
                heartColor = '#ffaaaa';
            }
            
            // Flash effect during invincibility
            if (player.invincibilityTimer > 0) {
                const flashRate = 8; // Flash every 8 frames
                if (Math.floor(player.invincibilityTimer / flashRate) % 2 === 0) {
                    ctx.globalAlpha = 0.3; // Make semi-transparent when flashing
                }
            }
            
            ctx.fillStyle = heartColor;
            const size = player.size;
            
            ctx.beginPath();
            ctx.moveTo(player.x, player.y + size/2);
            ctx.bezierCurveTo(player.x, player.y, player.x - size/2, player.y, player.x - size/2, player.y + size/4);
            ctx.bezierCurveTo(player.x - size/2, player.y + size/2, player.x, player.y + size/2, player.x, player.y + size);
            ctx.bezierCurveTo(player.x, player.y + size/2, player.x + size/2, player.y + size/2, player.x + size/2, player.y + size/4);
            ctx.bezierCurveTo(player.x + size/2, player.y, player.x, player.y, player.x, player.y + size/2);
            ctx.fill();
            
            // Reset alpha
            ctx.globalAlpha = 1;
            
            if (player.statusEffects.sleepy > 0) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.fillText('zzz', player.x + 12, player.y - 5);
            }
        }
        
        function updateAttacks() {
            for (let i = attacks.length - 1; i >= 0; i--) {
                const attack = attacks[i];
                
                switch(attack.type) {
                    case 'yarnball':
                        attack.x += attack.dx;
                        attack.y += attack.dy;
                        if (attack.x <= battleBox.x || attack.x >= battleBox.x + battleBox.width) {
                            attack.dx *= -1;
                            attack.bounces--;
                        }
                        if (attack.bounces <= 0) {
                            attacks.splice(i, 1);
                            continue;
                        }
                        break;
                        
                    case 'mouse':
                        const angle = Math.atan2(attack.targetY - attack.y, attack.targetX - attack.x);
                        attack.x += Math.cos(angle) * attack.speed;
                        attack.y += Math.sin(angle) * attack.speed;
                        break;

                    case 'megalovania':
                        if (attack.targetX !== undefined) {
                            const angle = Math.atan2(attack.targetY - attack.y, attack.targetX - attack.x);
                            attack.x += Math.cos(angle) * attack.speed;
                            attack.y += Math.sin(angle) * attack.speed;
                        } else {
                            attack.x += (attack.dx || 0);
                            attack.y += (attack.dy || 0);
                        }
                        break;

                    case 'determination':
                        attack.x += attack.dx;
                        attack.y += attack.dy;
                        if (attack.trail) {
                            attack.trail.push({x: attack.x, y: attack.y});
                            if (attack.trail.length > 5) {
                                attack.trail.shift();
                            }
                        }
                        break;

                    case 'spiralHealing':
                        attack.x += attack.dx;
                        attack.y += attack.dy;
                        // Add spiral movement
                        if (attack.spiralSpeed) {
                            const spiralAngle = frameCount * attack.spiralSpeed;
                            attack.dx += Math.cos(spiralAngle) * 0.1;
                            attack.dy += Math.sin(spiralAngle) * 0.1;
                        }
                        if (attack.trail) {
                            attack.trail.push({x: attack.x, y: attack.y});
                            if (attack.trail.length > 6) {
                                attack.trail.shift();
                            }
                        }
                        break;

                    case 'healingWave':
                        attack.x += attack.dx;
                        attack.y += attack.dy + Math.sin(frameCount * 0.1 + attack.waveOffset) * 1.5;
                        break;

                    case 'healingBurst':
                        attack.x += attack.dx;
                        attack.y += attack.dy;
                        if (attack.expandTimer !== undefined) {
                            attack.expandTimer++;
                            attack.size = Math.min(15, 8 + attack.expandTimer * 0.1);
                        }
                        break;

                    case 'flowingHealing':
                        attack.x += attack.dx + Math.sin(frameCount * 0.08 + attack.flowPhase) * 2;
                        attack.y += attack.dy;
                        if (attack.trail) {
                            attack.trail.push({x: attack.x, y: attack.y});
                            if (attack.trail.length > 8) {
                                attack.trail.shift();
                            }
                        }
                        break;

                    case 'mercyHealing':
                    case 'emergencyTreats':
                        attack.x += attack.dx;
                        attack.y += attack.dy;
                        if (attack.timer) {
                            attack.timer--;
                            if (attack.timer <= 0) {
                                attacks.splice(i, 1);
                                continue;
                            }
                        }
                        if (attack.pulse !== undefined) {
                            attack.pulse += 0.1;
                        }
                        break;
                        
                    case 'string':
                        attack.x += attack.dx;
                        attack.y += attack.dy + Math.sin(frameCount * 0.15 + attack.waveOffset) * 2;
                        break;
                        
                    case 'zoomies':
                    case 'orangeZoomies':
                        attack.x += attack.dx;
                        attack.y += attack.dy;
                        // Add spiral effect if present
                        if (attack.spiralFactor) {
                            const spiralAngle = frameCount * attack.spiralFactor;
                            attack.dx += Math.cos(spiralAngle) * 0.05;
                            attack.dy += Math.sin(spiralAngle) * 0.05;
                        }
                        if (attack.trail) {
                            attack.trail.push({x: attack.x, y: attack.y});
                            if (attack.trail.length > 8) {
                                attack.trail.shift();
                            }
                        }
                        break;
                        
                    case 'blueBones':
                        attack.x += attack.dx;
                        attack.y += attack.dy;
                        break;
                        
                    case 'catnip':
                        attack.timer--;
                        attack.x += attack.dx;
                        attack.y += attack.dy;
                        if (attack.timer <= 0) {
                            attacks.splice(i, 1);
                            continue;
                        }
                        break;
                        
                    case 'cardboard':
                    case 'hiding':
                    case 'litter':
                        attack.timer--;
                        if (attack.timer <= 0) {
                            attacks.splice(i, 1);
                            continue;
                        }
                        break;
                        
                    case 'pawswipe':
                    case 'enragedSwipe':
                        attack.timer--;
                        if (attack.timer <= 0) {
                            attacks.splice(i, 1);
                            continue;
                        }
                        break;
                        
                    case 'laser':
                        attack.x += attack.dx;
                        attack.y += attack.dy;
                        if (attack.trail) {
                            attack.trail.push({x: attack.x, y: attack.y});
                            if (attack.trail.length > 10) {
                                attack.trail.shift();
                            }
                        }
                        break;
                        
                    default:
                        attack.x += attack.dx;
                        attack.y += attack.dy;
                }
                
                if (!['cardboard', 'hiding', 'litter', 'pawswipe', 'enragedSwipe'].includes(attack.type)) {
                    if (attack.x < battleBox.x - 50 || attack.x > battleBox.x + battleBox.width + 50 || 
                        attack.y < battleBox.y - 50 || attack.y > battleBox.y + battleBox.height + 50) {
                        attacks.splice(i, 1);
                        continue;
                    }
                }
                
                drawAttack(attack);
            }
        }
        
        function drawAttack(attack) {
            ctx.fillStyle = attack.color;
            
            switch(attack.type) {
                case 'yarnball':
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, attack.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ff1493';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    break;
                    
                case 'mouse':
                    ctx.fillRect(attack.x - attack.size/2, attack.y - attack.size/2, attack.size, attack.size);
                    ctx.strokeStyle = attack.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(attack.x + attack.size/2, attack.y);
                    ctx.lineTo(attack.x + attack.size, attack.y + attack.size/2);
                    ctx.stroke();
                    break;

                case 'megalovania':
                    if (attack.height) {
                        // Bone-like attack
                        ctx.fillRect(attack.x - attack.size/2, attack.y, attack.size, attack.height);
                        ctx.strokeStyle = '#4169e1';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(attack.x - attack.size/2, attack.y, attack.size, attack.height);
                    } else {
                        // Circular projectile
                        ctx.beginPath();
                        ctx.arc(attack.x, attack.y, attack.size/2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = attack.attackColor === 'blue' ? '#4169e1' : '#ff8c00';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    break;

                case 'determination':
                    if (attack.trail && attack.trail.length > 1) {
                        ctx.strokeStyle = attack.color;
                        ctx.lineWidth = attack.size;
                        ctx.beginPath();
                        ctx.moveTo(attack.trail[0].x, attack.trail[0].y);
                        for (let j = 1; j < attack.trail.length; j++) {
                            ctx.lineTo(attack.trail[j].x, attack.trail[j].y);
                        }
                        ctx.stroke();
                    }
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, attack.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'spiralHealing':
                    // Enhanced spiral healing visual
                    if (attack.trail && attack.trail.length > 1) {
                        ctx.strokeStyle = '#44ff88';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(attack.trail[0].x, attack.trail[0].y);
                        for (let j = 1; j < attack.trail.length; j++) {
                            ctx.lineTo(attack.trail[j].x, attack.trail[j].y);
                        }
                        ctx.stroke();
                    }
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, attack.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#88ffaa';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    break;

                case 'healingWave':
                    // Wave healing visual with trail effect
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, attack.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#66ff66';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    break;

                case 'healingBurst':
                    // Burst healing visual with expanding effect
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, attack.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    // Outer ring
                    ctx.strokeStyle = '#88ff88';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    break;

                case 'flowingHealing':
                    // Flowing healing with trail
                    if (attack.trail && attack.trail.length > 1) {
                        ctx.strokeStyle = '#aaffaa';
                        ctx.lineWidth = 6;
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        ctx.moveTo(attack.trail[0].x, attack.trail[0].y);
                        for (let j = 1; j < attack.trail.length; j++) {
                            ctx.lineTo(attack.trail[j].x, attack.trail[j].y);
                        }
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, attack.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'mercyHealing':
                case 'emergencyTreats':
                    // Enhanced healing visual with pulse
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, attack.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Add pulse effect
                    const pulseMultiplier = attack.pulse ? (1 + Math.sin(attack.pulse) * 0.3) : (1 + Math.sin(frameCount * 0.15) * 0.3);
                    const pulseSize = attack.size * pulseMultiplier;
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, pulseSize/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    // Add sparkles
                    if (frameCount % 8 === 0) {
                        ctx.fillStyle = '#ffffff';
                        for (let j = 0; j < 2; j++) {
                            const sparkleX = attack.x + (Math.random() - 0.5) * attack.size;
                            const sparkleY = attack.y + (Math.random() - 0.5) * attack.size;
                            ctx.fillRect(sparkleX - 1, sparkleY - 1, 2, 2);
                        }
                    }
                    break;
                    
                case 'string':
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, attack.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'zoomies':
                case 'orangeZoomies':
                    if (attack.trail && attack.trail.length > 1) {
                        ctx.strokeStyle = attack.color;
                        ctx.lineWidth = attack.size/2;
                        ctx.beginPath();
                        ctx.moveTo(attack.trail[0].x, attack.trail[0].y);
                        for (let j = 1; j < attack.trail.length; j++) {
                            ctx.lineTo(attack.trail[j].x, attack.trail[j].y);
                        }
                        ctx.stroke();
                    }
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, attack.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'blueBones':
                    // Blue attacks - special visual indicator
                    ctx.fillRect(attack.x - attack.size/2, attack.y - attack.size/2, attack.size, attack.size);
                    ctx.strokeStyle = '#4169e1';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(attack.x - attack.size/2, attack.y - attack.size/2, attack.size, attack.size);
                    break;
                    
                case 'healingTreats':
                    // Green healing attacks - special visual
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, attack.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#00cc00';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    // Add sparkle effect
                    if (frameCount % 12 === 0) {
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(attack.x - 1, attack.y - 1, 2, 2);
                    }
                    break;
                    
                case 'cardboard':
                    ctx.fillRect(attack.x, attack.y, attack.size, attack.size);
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(attack.x, attack.y, attack.size, attack.size);
                    ctx.strokeRect(attack.x + 5, attack.y + 5, attack.size - 10, attack.size - 10);
                    break;
                    
                case 'hiding':
                    ctx.globalAlpha = 0.7;
                    ctx.fillRect(attack.x, attack.y, attack.size, 20);
                    ctx.globalAlpha = 1.0;
                    if (attack.timer % 60 < 30) {
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(attack.x + 10, attack.y + 5, 3, 3);
                        ctx.fillRect(attack.x + 20, attack.y + 5, 3, 3);
                    }
                    break;
                    
                case 'litter':
                    ctx.fillRect(attack.x, attack.y, attack.size, attack.size);
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(attack.x, attack.y, attack.size, attack.size);
                    for (let j = 0; j < 5; j++) {
                        ctx.fillStyle = '#DDD';
                        ctx.beginPath();
                        ctx.arc(attack.x + 5 + j * 6, attack.y + 10, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'laser':
                    if (attack.trail && attack.trail.length > 1) {
                        ctx.strokeStyle = attack.color;
                        ctx.lineWidth = attack.size;
                        ctx.beginPath();
                        for (let j = 0; j < attack.trail.length; j++) {
                            if (j === 0) {
                                ctx.moveTo(attack.trail[j].x, attack.trail[j].y);
                            } else {
                                ctx.lineTo(attack.trail[j].x, attack.trail[j].y);
                            }
                        }
                        ctx.stroke();
                    }
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, attack.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'catnip':
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, attack.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    break;
                    
                case 'pawswipe':
                case 'enragedSwipe':
                    // Use the cat paw image if loaded, otherwise fallback to rectangle
                    if (imageLoaded && catPawImage) {
                        try {
                            // Draw the cat paw image
                            ctx.drawImage(catPawImage, attack.x, attack.y, attack.size, attack.size);
                        } catch (error) {
                            console.warn('Failed to draw cat paw image:', error);
                            // Fallback to rectangle
                            ctx.fillRect(attack.x, attack.y, attack.size, attack.size);
                        }
                    } else {
                        // Fallback to rectangle if image not loaded
                        ctx.fillRect(attack.x, attack.y, attack.size, attack.size);
                    }
                    break;
                    
                default:
                    ctx.fillRect(attack.x - attack.size/2, attack.y - attack.size/2, attack.size, attack.size);
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.timer--;
                
                if (particle.timer <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                if (particle.type === 'warning') {
                    const flash = Math.sin(particle.timer * 0.4) > 0;
                    if (flash) {
                        ctx.strokeStyle = particle.color;
                        ctx.lineWidth = 3;
                        ctx.strokeRect(particle.x - particle.size/2, particle.y - particle.size/2, 
                                     particle.size, particle.size);
                    }
                } else if (particle.type === 'destruction') {
                    // Update destruction particles
                    particle.x += particle.dx;
                    particle.y += particle.dy;
                    particle.dy += 0.3; // gravity
                    
                    ctx.fillStyle = particle.color;
                    ctx.globalAlpha = particle.timer / 90;
                    ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
                    ctx.globalAlpha = 1;
                }
            }
        }
        
        function checkCollisions() {
            // Don't check collisions if game has ended
            if (gameState === 'win' || gameState === 'gameover' || gameState === 'player_death' || gameState === 'death_animation') {
                return;
            }
            
            for (let i = attacks.length - 1; i >= 0; i--) {
                const attack = attacks[i];
                let distance;
                let collision = false;
                
                if (['cardboard', 'hiding', 'litter', 'pawswipe', 'enragedSwipe'].includes(attack.type)) {
                    if (player.x > attack.x && player.x < attack.x + attack.size &&
                        player.y > attack.y && player.y < attack.y + attack.size) {
                        collision = true;
                    }
                } else {
                    distance = Math.sqrt(
                        Math.pow(player.x - attack.x, 2) + Math.pow(player.y - attack.y, 2)
                    );
                    
                    if (distance < player.size + attack.size/2) {
                        collision = true;
                    }
                }
                
                if (collision) {
                    handlePlayerHit(attack);
                    // Remove attack after collision, except for catnip which creates a lingering effect
                    if (attack.type !== 'catnip') {
                        attacks.splice(i, 1);
                    }
                }
            }
        }
        
        function handlePlayerHit(attack) {
            let damage = 1;
            let shouldTakeDamage = true;
            
            // Handle different attack colors
            if (attack.attackColor === 'blue') {
                // Blue attacks only hurt when moving
                shouldTakeDamage = player.isMoving;
            } else if (attack.attackColor === 'orange') {
                // Orange attacks only hurt when still
                shouldTakeDamage = !player.isMoving;
            } else if (attack.attackColor === 'green') {
                // Green attacks heal - always work regardless of invincibility
                const healAmount = attack.healAmount || 2;
                player.hp = Math.min(player.maxHP, player.hp + healAmount);
                updateStats();
                return;
            }
            
            // Check invincibility for damage attacks
            if (shouldTakeDamage && player.invincibilityTimer > 0 && attack.attackColor !== 'green') {
                return; // Player is invincible, no damage
            }
            
            if (!shouldTakeDamage) return;
            
            // Different attacks do different damage
            switch(attack.type) {
                case 'pawswipe':
                case 'scratching':
                    damage = 2;
                    break;
                case 'enragedSwipe':
                    damage = 3;
                    break;
                case 'megalovania':
                case 'determination':
                    damage = 2;
                    break;
                case 'treats':
                    if (boss.mood !== 'friendly') {
                        damage = 1;
                    } else {
                        player.hp = Math.min(player.maxHP, player.hp + 1);
                        updateStats();
                        return;
                    }
                    break;
                case 'healingTreats':
                case 'spiralHealing':
                case 'healingWave':
                case 'healingBurst':
                case 'flowingHealing':
                    player.hp = Math.min(player.maxHP, player.hp + (attack.healAmount || 2));
                    updateStats();
                    return;
                case 'mercyHealing':
                    player.hp = Math.min(player.maxHP, player.hp + (attack.healAmount || 3));
                    updateStats();
                    return;
                case 'emergencyTreats':
                    player.hp = Math.min(player.maxHP, player.hp + (attack.healAmount || 5));
                    updateStats();
                    return;
                case 'catnip':
                    player.statusEffects.catnip = Math.max(player.statusEffects.catnip || 0, 60);
                    damage = 0;
                    break;
            }
            
            if (damage > 0) {
                player.hp = Math.max(0, player.hp - damage);
                player.invincibilityTimer = player.invincibilityDuration; // Set invincibility
                updateStats();
                
                // Check for immediate death
                if (player.hp <= 0 && gameState === 'attack') {
                    // Don't call handlePlayerDeath here, let the main game loop handle it
                    return;
                }
            }
        }
        
        // Initialize and start the game
        updateStats();
        updateUILanguage();
        gameLoop();
    </script>
</body>
</html>